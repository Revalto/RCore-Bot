/// <reference types="node" />
import { inspect } from 'util';
import { Readable } from 'stream';
import VK from '../vk';
import { UsersUserFull, GroupsGroupFull } from '../api/schemas/objects';
export interface ICollectStreamOptions {
    options: Record<string, any> & {
        parallelCount?: number;
        count?: number;
        offset?: number;
    };
    method: string;
    limit: number;
    max?: number;
}
export interface ICollectStreamResult<T> {
    items: T[];
    profiles: UsersUserFull[];
    groups: GroupsGroupFull[];
}
export interface ICollectChunkData<T> {
    received: number;
    percent: number;
    total: number;
    items: T[];
    profiles: UsersUserFull[];
    groups: GroupsGroupFull[];
}
export default class CollectStream<T> extends Readable {
    protected vk: VK;
    protected method: string;
    protected code: string;
    protected parallelCount: number;
    protected total: number | undefined;
    protected offset: number;
    protected skipOffset: number;
    protected received: number;
    protected attempts: number;
    protected supportExecute: boolean;
    protected promise: Promise<ICollectStreamResult<T>> | null;
    protected params: Record<string, any>;
    /**
     * Constructor
     */
    constructor(vk: VK, { options, method, limit, max }: ICollectStreamOptions);
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag](): string;
    /**
     * Promise based
     */
    then(thenFn: (result: ICollectStreamResult<T>) => any, catchFn?: (error: Error) => any): Promise<ICollectStreamResult<T>>;
    /**
     * Fetch data
     */
    _read(): Promise<void>;
    /**
     * Custom inspect object
     */
    [inspect.custom](depth: number, options: Record<string, any>): string;
    on(event: 'close', listener: () => void): this;
    on(event: 'data', listener: (chunk: ICollectChunkData<T>) => void): this;
    on(event: 'end', listener: () => void): this;
    on(event: 'readable', listener: () => void): this;
    on(event: 'error', listener: (err: Error) => void): this;
    [Symbol.asyncIterator](): AsyncIterableIterator<ICollectChunkData<T>>;
}
