import { createServer, Agent } from 'https';
import { inspect, deprecate, promisify } from 'util';
import fetch from 'node-fetch';
import createDebug from 'debug';
import { URLSearchParams, URL } from 'url';
import { randomBytes } from 'crypto';
import { createReadStream } from 'fs';
import { Stream, PassThrough, Readable } from 'stream';
import { SandwichStream } from 'sandwich-stream';
import { compose, noopNext, getOptionalMiddleware, Composer as Composer$1 } from 'middleware-io';
import { createServer as createServer$1 } from 'http';

class APIMethods {
}

var version = "4.0.0-rc.29";

// @ts-ignore
/**
 * Chat peer ID
 */
const CHAT_PEER = 2e9;
/**
 * Minimum time interval api with error
 */
const MINIMUM_TIME_INTERVAL_API = 1133;
/**
 * Default options
 */
const defaultOptions = {
    // @ts-ignore
    agent: null,
    token: null,
    language: null,
    appId: null,
    appSecret: null,
    login: null,
    phone: null,
    password: null,
    authScope: null,
    authTimeout: 10e3,
    apiMode: 'sequential',
    apiWait: 3e3,
    apiLimit: 3,
    apiVersion: '5.103',
    apiBaseUrl: 'https://api.vk.com/method',
    apiAttempts: 3,
    apiTimeout: 10e3,
    apiHeaders: {
        'User-Agent': `vk-io/${version} (+https://github.com/negezor/vk-io)`
    },
    apiExecuteCount: 25,
    apiExecuteMethods: ['messages.send'],
    uploadTimeout: 20e3,
    pollingWait: 3e3,
    pollingAttempts: 3,
    pollingGroupId: null,
    webhookSecret: null,
    webhookConfirmation: null,
    collectAttempts: 3
};
/**
 * The attachment types
 */
var AttachmentType;
(function (AttachmentType) {
    AttachmentType["AUDIO"] = "audio";
    AttachmentType["AUDIO_MESSAGE"] = "audio_message";
    AttachmentType["GRAFFITI"] = "graffiti";
    AttachmentType["DOCUMENT"] = "doc";
    AttachmentType["GIFT"] = "gift";
    AttachmentType["LINK"] = "link";
    AttachmentType["MARKET_ALBUM"] = "market_album";
    AttachmentType["MARKET"] = "market";
    AttachmentType["PHOTO"] = "photo";
    AttachmentType["STICKER"] = "sticker";
    AttachmentType["VIDEO"] = "video";
    AttachmentType["WALL_REPLY"] = "wall_reply";
    AttachmentType["WALL"] = "wall";
    AttachmentType["POLL"] = "poll";
    AttachmentType["STORY"] = "story";
})(AttachmentType || (AttachmentType = {}));
const attachmentTypes = AttachmentType;
/**
 * Default extensions for attachments
 */
var DefaultExtension;
(function (DefaultExtension) {
    DefaultExtension["photo"] = "jpg";
    DefaultExtension["video"] = "mp4";
    DefaultExtension["audio"] = "mp3";
    DefaultExtension["graffiti"] = "png";
    DefaultExtension["audioMessage"] = "ogg";
})(DefaultExtension || (DefaultExtension = {}));
/**
 * Default content type for attachments
 */
var DefaultContentType;
(function (DefaultContentType) {
    DefaultContentType["photo"] = "image/jpeg";
    DefaultContentType["video"] = "video/mp4";
    DefaultContentType["audio"] = "audio/mp3";
    DefaultContentType["graffiti"] = "image/png";
    DefaultContentType["audioMessage"] = "audio/ogg";
})(DefaultContentType || (DefaultContentType = {}));
/**
 * Sources of captcha
 */
var CaptchaType;
(function (CaptchaType) {
    CaptchaType[CaptchaType["API"] = 0] = "API";
    CaptchaType[CaptchaType["DIRECT_AUTH"] = 1] = "DIRECT_AUTH";
    CaptchaType[CaptchaType["IMPLICIT_FLOW_AUTH"] = 2] = "IMPLICIT_FLOW_AUTH";
    CaptchaType[CaptchaType["ACCOUNT_VERIFICATION"] = 3] = "ACCOUNT_VERIFICATION";
})(CaptchaType || (CaptchaType = {}));
const captchaTypes = CaptchaType;
/**
 * Message source
 */
var MessageSource;
(function (MessageSource) {
    MessageSource["USER"] = "user";
    MessageSource["CHAT"] = "chat";
    MessageSource["GROUP"] = "group";
    MessageSource["EMAIL"] = "email";
})(MessageSource || (MessageSource = {}));
const messageSources = MessageSource;
/**
 * Resource types
 */
var ResourceType;
(function (ResourceType) {
    ResourceType["USER"] = "user";
    ResourceType["GROUP"] = "group";
    ResourceType["APPLICATION"] = "application";
})(ResourceType || (ResourceType = {}));
const resourceTypes = ResourceType;
/**
 * Updates sources
 */
var UpdateSource;
(function (UpdateSource) {
    UpdateSource["POLLING"] = "POLLING";
    UpdateSource["WEBHOOK"] = "WEBHOOK";
    UpdateSource["WEBSOCKET"] = "WEBSOCKET";
})(UpdateSource || (UpdateSource = {}));
/**
 * API error codes
 */
var APIErrorCode;
(function (APIErrorCode) {
    APIErrorCode[APIErrorCode["UNKNOWN_ERROR"] = 1] = "UNKNOWN_ERROR";
    APIErrorCode[APIErrorCode["APP_SWITCHED_OFF"] = 2] = "APP_SWITCHED_OFF";
    APIErrorCode[APIErrorCode["UNKNOWN_METHOD"] = 3] = "UNKNOWN_METHOD";
    APIErrorCode[APIErrorCode["INVALID_SIGNATURE"] = 4] = "INVALID_SIGNATURE";
    APIErrorCode[APIErrorCode["AUTH_FAILURE"] = 5] = "AUTH_FAILURE";
    APIErrorCode[APIErrorCode["TOO_MANY_REQUESTS"] = 6] = "TOO_MANY_REQUESTS";
    APIErrorCode[APIErrorCode["SCOPE_NEEDED"] = 7] = "SCOPE_NEEDED";
    APIErrorCode[APIErrorCode["INCORRECT_REQUEST"] = 8] = "INCORRECT_REQUEST";
    APIErrorCode[APIErrorCode["TOO_MANY_SIMILAR_ACTIONS"] = 9] = "TOO_MANY_SIMILAR_ACTIONS";
    APIErrorCode[APIErrorCode["INTERNAL_ERROR"] = 10] = "INTERNAL_ERROR";
    APIErrorCode[APIErrorCode["RESPONSE_SIZE_TOO_BIG"] = 13] = "RESPONSE_SIZE_TOO_BIG";
    APIErrorCode[APIErrorCode["CAPTCHA_REQUIRED"] = 14] = "CAPTCHA_REQUIRED";
    APIErrorCode[APIErrorCode["ACCESS_DENIED"] = 15] = "ACCESS_DENIED";
    APIErrorCode[APIErrorCode["USER_VALIDATION_REQUIRED"] = 17] = "USER_VALIDATION_REQUIRED";
    APIErrorCode[APIErrorCode["PAGE_BLOCKED"] = 18] = "PAGE_BLOCKED";
    APIErrorCode[APIErrorCode["STANDALONE_ONLY"] = 20] = "STANDALONE_ONLY";
    APIErrorCode[APIErrorCode["STANDALONE_AND_OPEN_API_ONLY"] = 21] = "STANDALONE_AND_OPEN_API_ONLY";
    APIErrorCode[APIErrorCode["METHOD_DISABLED"] = 23] = "METHOD_DISABLED";
    APIErrorCode[APIErrorCode["CONFIRMATION_REQUIRED"] = 24] = "CONFIRMATION_REQUIRED";
    APIErrorCode[APIErrorCode["GROUP_TOKEN_NOT_VALID"] = 27] = "GROUP_TOKEN_NOT_VALID";
    APIErrorCode[APIErrorCode["APP_TOKEN_NOT_VALID"] = 28] = "APP_TOKEN_NOT_VALID";
    APIErrorCode[APIErrorCode["METHOD_CALL_LIMIT"] = 29] = "METHOD_CALL_LIMIT";
    APIErrorCode[APIErrorCode["PROFILE_IS_PRIVATE"] = 30] = "PROFILE_IS_PRIVATE";
    APIErrorCode[APIErrorCode["WRONG_PARAMETER"] = 100] = "WRONG_PARAMETER";
    APIErrorCode[APIErrorCode["INVALID_APPLICATION_ID"] = 101] = "INVALID_APPLICATION_ID";
    APIErrorCode[APIErrorCode["LIMIT_ENTRY_EXHAUSTED"] = 103] = "LIMIT_ENTRY_EXHAUSTED";
    APIErrorCode[APIErrorCode["INCORRECT_USER_ID"] = 113] = "INCORRECT_USER_ID";
    APIErrorCode[APIErrorCode["INVALID_TIMESTAMP"] = 150] = "INVALID_TIMESTAMP";
    APIErrorCode[APIErrorCode["ALBUM_ACCESS_DENIED"] = 200] = "ALBUM_ACCESS_DENIED";
    APIErrorCode[APIErrorCode["AUDIO_ACCESS_DENIED"] = 201] = "AUDIO_ACCESS_DENIED";
    APIErrorCode[APIErrorCode["GROUP_ACCESS_DENIED"] = 203] = "GROUP_ACCESS_DENIED";
    APIErrorCode[APIErrorCode["ALBUM_OVERFLOW"] = 300] = "ALBUM_OVERFLOW";
    APIErrorCode[APIErrorCode["PAYMENTS_DISABLED"] = 500] = "PAYMENTS_DISABLED";
    APIErrorCode[APIErrorCode["COMMERCIAL_ACCESS_DENIED"] = 600] = "COMMERCIAL_ACCESS_DENIED";
    APIErrorCode[APIErrorCode["COMMERCIAL_ERROR"] = 603] = "COMMERCIAL_ERROR";
    APIErrorCode[APIErrorCode["BLACKLISTED_USER"] = 900] = "BLACKLISTED_USER";
    APIErrorCode[APIErrorCode["MESSAGE_COMMUNITY_BLOCKED_BY_USER"] = 901] = "MESSAGE_COMMUNITY_BLOCKED_BY_USER";
    APIErrorCode[APIErrorCode["MESSAGE_BLOCKED_BY_USER_PRIVACY"] = 902] = "MESSAGE_BLOCKED_BY_USER_PRIVACY";
    APIErrorCode[APIErrorCode["UNABLE_TO_EDIT_MESSAGE_AFTER_DAY"] = 909] = "UNABLE_TO_EDIT_MESSAGE_AFTER_DAY";
    APIErrorCode[APIErrorCode["MESSAGE_CANNOT_EDIT_IS_TOO_LONG"] = 910] = "MESSAGE_CANNOT_EDIT_IS_TOO_LONG";
    APIErrorCode[APIErrorCode["KEYBOARD_FORMAT_IS_INVALID"] = 911] = "KEYBOARD_FORMAT_IS_INVALID";
    APIErrorCode[APIErrorCode["CHAT_BOT_FEATURE"] = 912] = "CHAT_BOT_FEATURE";
    APIErrorCode[APIErrorCode["TOO_MANY_FORWARDED_MESSAGES"] = 913] = "TOO_MANY_FORWARDED_MESSAGES";
    APIErrorCode[APIErrorCode["MESSAGE_TOO_LONG"] = 914] = "MESSAGE_TOO_LONG";
    APIErrorCode[APIErrorCode["NO_ACCESS_TO_CONVERSATION"] = 917] = "NO_ACCESS_TO_CONVERSATION";
    APIErrorCode[APIErrorCode["CANNOT_EDIT_THIS_TYPE_MESSAGE"] = 920] = "CANNOT_EDIT_THIS_TYPE_MESSAGE";
    APIErrorCode[APIErrorCode["UNABLE_TO_FORWARD_MESSAGES"] = 921] = "UNABLE_TO_FORWARD_MESSAGES";
    APIErrorCode[APIErrorCode["UNABLE_TO_DELETE_MESSAGE_FOR_RECIPIENTS"] = 924] = "UNABLE_TO_DELETE_MESSAGE_FOR_RECIPIENTS";
    APIErrorCode[APIErrorCode["NOT_ADMIN_CHAT"] = 925] = "NOT_ADMIN_CHAT";
    APIErrorCode[APIErrorCode["COMMUNITY_CANNOT_INTERACT_WITH_THIS_PEER"] = 932] = "COMMUNITY_CANNOT_INTERACT_WITH_THIS_PEER";
    APIErrorCode[APIErrorCode["CONTACT_NOT_FOUND"] = 936] = "CONTACT_NOT_FOUND";
})(APIErrorCode || (APIErrorCode = {}));
const apiErrors = APIErrorCode;
/**
 * Upload error codes
 */
var UploadErrorCode;
(function (UploadErrorCode) {
    UploadErrorCode["MISSING_PARAMETERS"] = "MISSING_PARAMETERS";
    UploadErrorCode["NO_FILES_TO_UPLOAD"] = "NO_FILES_TO_UPLOAD";
    UploadErrorCode["EXCEEDED_MAX_FILES"] = "EXCEEDED_MAX_FILES";
    UploadErrorCode["UNSUPPORTED_SOURCE_TYPE"] = "UNSUPPORTED_SOURCE_TYPE";
})(UploadErrorCode || (UploadErrorCode = {}));
const uploadErrors = UploadErrorCode;
/**
 * Updates error codes
 */
var UpdatesErrorCode;
(function (UpdatesErrorCode) {
    UpdatesErrorCode["NEED_RESTART"] = "NEED_RESTART";
    UpdatesErrorCode["POLLING_REQUEST_FAILED"] = "POLLING_REQUEST_FAILED";
})(UpdatesErrorCode || (UpdatesErrorCode = {}));
const updatesErrors = UpdatesErrorCode;
/**
 * Collect error codes
 */
var CollectErrorCode;
(function (CollectErrorCode) {
    CollectErrorCode["EXECUTE_ERROR"] = "EXECUTE_ERROR";
})(CollectErrorCode || (CollectErrorCode = {}));
const collectErrors = CollectErrorCode;
/**
 * Snippets error codes
 */
var SnippetErrorCode;
(function (SnippetErrorCode) {
    SnippetErrorCode["INVALID_URL"] = "INVALID_URL";
    SnippetErrorCode["INVALID_RESOURCE"] = "INVALID_RESOURCE";
    SnippetErrorCode["RESOURCE_NOT_FOUND"] = "RESOURCE_NOT_FOUND";
})(SnippetErrorCode || (SnippetErrorCode = {}));
const snippetsErrors = SnippetErrorCode;
/**
 * Snippets error codes
 */
var SharedErrorCode;
(function (SharedErrorCode) {
    SharedErrorCode["MISSING_CAPTCHA_HANDLER"] = "MISSING_CAPTCHA_HANDLER";
    SharedErrorCode["MISSING_TWO_FACTOR_HANDLER"] = "MISSING_TWO_FACTOR_HANDLER";
})(SharedErrorCode || (SharedErrorCode = {}));
const sharedErrors = SharedErrorCode;
/**
 * VK Platforms
 */
const platforms = new Map([
    [1, 'mobile'],
    [2, 'iphone'],
    [3, 'ipad'],
    [4, 'android'],
    [5, 'wphone'],
    [6, 'windows'],
    [7, 'web'],
    [8, 'standalone']
]);
/**
 * Parse attachments with RegExp
 */
const parseAttachment = /(photo|video|audio|doc|audio_message|graffiti|wall|market|poll|gift)([-\d]+)_(\d+)_?(\w+)?/;
/**
 * Parse resource with RegExp
 */
const parseResource = /(id|club|public|albums|tag|app(?:lication))([-\d]+)/;
/**
 * Parse owner resource with RegExp
 */
const parseOwnerResource = /(album|topic|wall|page|videos)([-\d]+)_(\d+)/;
/**
 * Inspect custom data
 */
const inspectCustomData = Symbol('inspectCustomData');

/**
 * Returns method for execute
 */
const getExecuteMethod = (method, params = {}) => {
    const options = {};
    for (const [key, value] of Object.entries(params)) {
        options[key] = typeof value === 'object'
            ? String(value)
            : value;
    }
    return `API.${method}(${JSON.stringify(options)})`;
};
/**
 * Returns chain for execute
 */
const getChainReturn = (methods) => (`return [${methods.join(',')}];`);
/**
 * Resolve task
 */
const resolveExecuteTask = (tasks, result) => {
    let errors = 0;
    result.response.forEach((response, i) => {
        if (response !== false) {
            tasks[i].resolve(response);
            return;
        }
        tasks[i].reject(result.errors[errors]);
        errors += 1;
    });
};
/**
 * Returns random ID
 */
const getRandomId = () => (`${Math.floor(Math.random() * 1e4)}${Date.now()}`);
/**
 * Delay N-ms
 */
const delay = (delayed) => (new Promise((resolve) => {
    setTimeout(resolve, delayed);
}));
const lt = /&lt;/g;
const qt = /&gt;/g;
const br = /<br>/g;
const amp = /&amp;/g;
const quot = /&quot;/g;
/**
 * Decodes HTML entities
 */
const unescapeHTML = (text) => (text
    .replace(lt, '<')
    .replace(qt, '>')
    .replace(br, '\n')
    .replace(amp, '&')
    .replace(quot, '"'));
/**
 * Copies object params to new object
 */
const copyParams = (params, properties) => {
    // @ts-ignore
    const copies = {};
    for (const property of properties) {
        copies[property] = params[property];
    }
    return copies;
};
/**
 * Returns peer id type
 */
const getPeerType = (id) => {
    if (CHAT_PEER < id) {
        return MessageSource.CHAT;
    }
    if (id < 0) {
        return MessageSource.GROUP;
    }
    return MessageSource.USER;
};
/**
 * Displays deprecated message
 */
const showDeprecatedMessage = (message) => {
    // eslint-disable-next-line no-console
    console.log(' \u001b[31mDeprecated:\u001b[39m', message);
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const applyMixins = (derivedCtor, baseCtors) => {
    for (const baseCtor of baseCtors) {
        for (const name of Object.getOwnPropertyNames(baseCtor.prototype)) {
            if (name === 'constructor') {
                continue;
            }
            Object.defineProperty(derivedCtor.prototype, name, 
            // @ts-ignore
            Object.getOwnPropertyDescriptor(baseCtor.prototype, name));
        }
    }
};

class APIRequest {
    /**
     * Constructor
     */
    constructor({ method, params = {} }) {
        this.attempts = 0;
        this.method = method;
        this.params = { ...params };
        this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
        });
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Adds attempt
     */
    addAttempt() {
        this.attempts += 1;
        return this.attempts;
    }
    /**
     * Returns string to execute
     */
    toString() {
        return getExecuteMethod(this.method, this.params);
    }
    /**
     * Custom inspect object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [inspect.custom](depth, options) {
        const { method, params, promise } = this;
        const payload = { method, params, promise };
        return `${options.stylize(this.constructor.name, 'special')} ${inspect(payload, options)}`;
    }
}

/**
 * General error class
 */
class VKError extends Error {
    /**
     * Constructor
     */
    constructor({ code, message }) {
        super(message);
        this.code = code;
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Returns property for json
     */
    toJSON() {
        const json = {};
        for (const key of Object.getOwnPropertyNames(this)) {
            // @ts-ignore
            json[key] = this[key];
        }
        return json;
    }
}

const { CAPTCHA_REQUIRED, USER_VALIDATION_REQUIRED, CONFIRMATION_REQUIRED } = APIErrorCode;
class APIError extends VKError {
    /**
     * Constructor
     */
    constructor(payload) {
        const code = Number(payload.error_code);
        const message = `Code â„–${code} - ${payload.error_msg}`;
        super({ code, message });
        this.params = payload.request_params;
        if (code === CAPTCHA_REQUIRED) {
            this.captchaSid = Number(payload.captcha_sid);
            this.captchaImg = payload.captcha_img;
        }
        else if (code === USER_VALIDATION_REQUIRED) {
            this.redirectUri = payload.redirect_uri;
        }
        else if (code === CONFIRMATION_REQUIRED) {
            this.confirmationText = payload.confirmation_text;
        }
    }
}

class UploadError extends VKError {
}

class CollectError extends VKError {
    /**
     * Constructor
     */
    constructor({ message, code, errors }) {
        super({ message, code });
        this.errors = errors;
    }
}

class UpdatesError extends VKError {
}

class ExecuteError extends APIError {
    /**
     * Constructor
     */
    constructor(options) {
        super({
            error_code: options.error_code,
            error_msg: options.error_msg,
            request_params: []
        });
        this.method = options.method;
    }
}

class SnippetsError extends VKError {
}

function sequential(api, next) {
    // @ts-ignore
    api.callMethod(api.queue.shift());
    next();
}

async function parallel(api, next) {
    // @ts-ignore
    const { queue } = api;
    if (queue[0].method.startsWith('execute')) {
        // @ts-ignore
        sequential(api, next);
        return;
    }
    // Wait next event loop, saves one request or more
    await delay(0);
    // @ts-ignore
    const { apiExecuteCount } = api.vk.options;
    const tasks = [];
    const chain = [];
    for (let i = 0; i < queue.length; i += 1) {
        if (queue[i].method.startsWith('execute')) {
            continue;
        }
        const [request] = queue.splice(i, 1);
        i -= 1;
        tasks.push(request);
        chain.push(String(request));
        if (tasks.length >= apiExecuteCount) {
            break;
        }
    }
    try {
        const request = new APIRequest({
            method: 'execute',
            params: {
                code: getChainReturn(chain)
            }
        });
        // @ts-ignore
        api.callMethod(request);
        next();
        resolveExecuteTask(tasks, await request.promise);
    }
    catch (error) {
        for (const task of tasks) {
            task.reject(error);
        }
    }
}

async function parallelSelected(api, next) {
    // @ts-ignore
    const { apiExecuteMethods, apiExecuteCount } = api.vk.options;
    // @ts-ignore
    const { queue } = api;
    if (!apiExecuteMethods.includes(queue[0].method)) {
        sequential(api, next);
        return;
    }
    // Wait next event loop, saves one request or more
    await delay(0);
    const tasks = [];
    const chain = [];
    for (let i = 0; i < queue.length; i += 1) {
        if (!apiExecuteMethods.includes(queue[i].method)) {
            continue;
        }
        const [request] = queue.splice(i, 1);
        i -= 1;
        tasks.push(request);
        chain.push(String(request));
        if (tasks.length >= apiExecuteCount) {
            break;
        }
    }
    if (tasks.length === 0) {
        sequential(api, next);
        return;
    }
    try {
        const request = new APIRequest({
            method: 'execute',
            params: {
                code: getChainReturn(chain)
            }
        });
        // @ts-ignore
        api.callMethod(request);
        next();
        resolveExecuteTask(tasks, await request.promise);
    }
    catch (error) {
        for (const task of tasks) {
            task.reject(error);
        }
    }
}

const { CAPTCHA_REQUIRED: CAPTCHA_REQUIRED$1, TOO_MANY_REQUESTS, USER_VALIDATION_REQUIRED: USER_VALIDATION_REQUIRED$1 } = APIErrorCode;
const debug = createDebug('vk-io:api');
const requestHandlers = {
    sequential,
    parallel,
    parallel_selected: parallelSelected
};
/**
 * Returns request handler
 */
const getRequestHandler = (mode = 'sequential') => {
    const handler = requestHandlers[mode];
    if (!handler) {
        throw new VKError({
            message: 'Unsuported api mode',
            code: 'UNSUPPORTED_MODE'
        });
    }
    return handler;
};
const groupMethods = [
    'account',
    'ads',
    'appWidgets',
    'apps',
    'audio',
    'auth',
    'board',
    'database',
    'docs',
    'fave',
    'friends',
    'gifts',
    'groups',
    'leads',
    'leadForms',
    'likes',
    'market',
    'messages',
    'newsfeed',
    'notes',
    'notifications',
    'orders',
    'pages',
    'photos',
    'places',
    'polls',
    'podcasts',
    'prettyCards',
    'search',
    'secure',
    'stats',
    'status',
    'storage',
    'stories',
    'streaming',
    'users',
    'utils',
    'video',
    'wall',
    'widgets',
    'junction'
];
/**
 * Working with API methods
 */
class API extends APIMethods {
    /**
     * Constructor
     */
    constructor(vk) {
        super();
        this.queue = [];
        this.started = false;
        this.suspended = false;
        this.vk = vk;
        for (const group of groupMethods) {
            const isMessagesGroup = group === 'messages';
            /**
             * NOTE: Optimization for other methods
             *
             * Instead of checking everywhere the presence of a property in an object
             * The check is only for the messages group
             * Since it is necessary to change the behavior of the sending method
             */
            // @ts-ignore
            this[group] = new Proxy(isMessagesGroup
                ? {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    send: (params = {}) => {
                        const messageParams = params.random_id === undefined
                            ? { ...params, random_id: getRandomId() }
                            : params;
                        return this.enqueue('messages.send', messageParams);
                    }
                }
                : {}, {
                get: isMessagesGroup
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    ? (obj, prop) => obj[prop] || (
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    (params) => (this.enqueue(`${group}.${prop}`, params)))
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    : (obj, prop) => (params) => (this.enqueue(`${group}.${prop}`, params))
            });
        }
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Returns the current used API version
     */
    get API_VERSION() {
        return this.vk.options.apiVersion;
    }
    /**
     * Call execute method
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    execute(params) {
        return this.enqueue('execute', params);
    }
    /**
     * Call execute procedure
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    procedure(name, params) {
        return this.enqueue(`execute.${name}`, params);
    }
    /**
     * Call raw method
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    call(method, params) {
        return this.enqueue(method, params);
    }
    /**
     * Adds request for queue
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    callWithRequest(request) {
        this.queue.push(request);
        this.worker();
        return request.promise;
    }
    /**
     * Adds method to queue
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    enqueue(method, params) {
        const request = new APIRequest({
            method,
            params
        });
        return this.callWithRequest(request);
    }
    /**
     * Adds an element to the beginning of the queue
     */
    requeue(request) {
        this.queue.unshift(request);
        this.worker();
    }
    /**
     * Running queue
     */
    worker() {
        if (this.started) {
            return;
        }
        this.started = true;
        const { apiLimit, apiMode } = this.vk.options;
        const handler = getRequestHandler(apiMode);
        const interval = Math.round(MINIMUM_TIME_INTERVAL_API / apiLimit);
        const work = () => {
            if (this.queue.length === 0 || this.suspended) {
                this.started = false;
                return;
            }
            handler(this, () => {
                setTimeout(work, interval);
            });
        };
        work();
    }
    /**
     * Calls the api method
     */
    async callMethod(request) {
        const { options } = this.vk;
        const { method } = request;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const params = {
            access_token: options.token,
            v: options.apiVersion,
            ...request.params
        };
        if (options.language !== null) {
            params.lang = options.language;
        }
        debug(`http --> ${method}`);
        const startTime = Date.now();
        let response;
        try {
            response = await fetch(`${options.apiBaseUrl}/${method}`, {
                method: 'POST',
                compress: false,
                agent: options.agent,
                timeout: options.apiTimeout,
                headers: {
                    ...options.apiHeaders,
                    connection: 'keep-alive'
                },
                body: new URLSearchParams(params)
            });
            response = await response.json();
        }
        catch (error) {
            if (request.addAttempt() <= options.apiAttempts) {
                await delay(options.apiWait);
                debug(`Request ${method} restarted ${request.attempts} times`);
                this.requeue(request);
                return;
            }
            if (request.captchaValidate) {
                request.captchaValidate.reject(error);
            }
            request.reject(error);
            return;
        }
        const endTime = (Date.now() - startTime).toLocaleString();
        debug(`http <-- ${method} ${endTime}ms`);
        if ('error' in response) {
            this.handleError(request, new APIError(response.error));
            return;
        }
        if (request.captchaValidate) {
            request.captchaValidate.resolve();
        }
        if (method.startsWith('execute')) {
            request.resolve({
                response: response.response,
                errors: (response.execute_errors || []).map((error) => (new ExecuteError(error)))
            });
            return;
        }
        request.resolve(response.response !== undefined
            ? response.response
            : response);
    }
    /**
     * Error API handler
     */
    async handleError(request, error) {
        const { code } = error;
        if (code === TOO_MANY_REQUESTS) {
            if (this.suspended) {
                this.requeue(request);
                return;
            }
            this.suspended = true;
            await delay((MINIMUM_TIME_INTERVAL_API / this.vk.options.apiLimit) + 50);
            this.suspended = false;
            this.requeue(request);
            return;
        }
        if (request.captchaValidate) {
            request.captchaValidate.reject(error);
        }
        if (code === USER_VALIDATION_REQUIRED$1) {
            if (this.suspended) {
                this.requeue(request);
            }
            let AccountVerification;
            try {
                // @ts-ignore
                AccountVerification = (await import('@vk-io/authorization')).AccountVerification;
            }
            catch (importError) {
                request.reject(error);
                return;
            }
            this.suspended = true;
            try {
                // @ts-ignore
                const verification = new AccountVerification(this.vk);
                const { token } = await verification.run(error.redirectUri);
                debug('Account verification passed');
                this.vk.token = token;
                this.suspended = false;
                this.requeue(request);
            }
            catch (verificationError) {
                debug('Account verification error', verificationError);
                request.reject(error);
                await delay(15e3);
                this.suspended = false;
                this.worker();
            }
            return;
        }
        if (code !== CAPTCHA_REQUIRED$1 || !this.vk.callbackService.hasCaptchaHandler) {
            request.reject(error);
            return;
        }
        try {
            const { captchaSid } = error;
            const { key, validate } = await this.vk.callbackService.processingCaptcha({
                type: CaptchaType.API,
                src: error.captchaImg,
                sid: captchaSid,
                request
            });
            request.captchaValidate = validate;
            request.params.captcha_sid = captchaSid;
            request.params.captcha_key = key;
            this.requeue(request);
        }
        catch (e) {
            request.reject(e);
        }
    }
    /**
     * Custom inspect object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [inspect.custom](depth, options) {
        const { started, queue } = this;
        const payload = { started, queue };
        return `${options.stylize(this.constructor.name, 'special')} ${inspect(payload, options)}`;
    }
}

/**
 * Check object is stream
 */
const isStream = (source) => (typeof source === 'object' && source instanceof Stream);
/**
 * Copies object params to new object
 */
const copyParams$1 = (params, properties) => {
    // @ts-ignore
    const copies = {};
    for (const property of properties) {
        if (property in params) {
            copies[property] = params[property];
        }
    }
    return copies;
};
/**
 * Returns buffer from stream in Promise
 */
const streamToBuffer = (stream) => (new Promise((resolve, reject) => {
    const accum = [];
    stream.on('error', reject);
    stream.on('end', () => {
        resolve(Buffer.concat(accum));
    });
    stream.on('data', (chunk) => {
        accum.push(chunk);
    });
}));

const CRNL = '\r\n';
class MultipartStream extends SandwichStream {
    /**
     * Constructor
     */
    constructor(boundary) {
        super({
            head: `--${boundary}${CRNL}`,
            tail: `${CRNL}--${boundary}--`,
            separator: `${CRNL}--${boundary}${CRNL}`
        });
        this.boundary = boundary;
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Adds part
     */
    addPart(part) {
        const partStream = new PassThrough();
        if ('headers' in part) {
            // @ts-ignore
            for (const [key, header] of Object.entries(part.headers)) {
                partStream.write(`${key}:${header}${CRNL}`);
            }
        }
        partStream.write(CRNL);
        if (isStream(part.body)) {
            part.body.pipe(partStream);
        }
        else {
            partStream.end(part.body);
        }
        this.add(partStream);
    }
    /**
     * Adds form data
     */
    append(field, body, { filename = null, headers = {} }) {
        let header = `form-data; name="${field}"`;
        if (filename !== null) {
            header += `; filename="${filename}"`;
        }
        this.addPart({
            headers: {
                ...headers,
                'Content-Disposition': header
            },
            body
        });
    }
}

class Attachment {
    /**
     * Constructor
     */
    constructor(type, ownerId, id, accessKey = null) {
        this.type = type;
        this.ownerId = Number(ownerId);
        this.id = Number(id);
        this.accessKey = accessKey;
        this.$filled = false;
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Parse attachment with string
     */
    static fromString(attachment) {
        if (!parseAttachment.test(attachment)) {
            throw new TypeError('Incorrect attachment');
        }
        const [, type, ownerId, id, accessKey] = attachment.match(parseAttachment);
        return new Attachment(type, ownerId, id, accessKey);
    }
    /**
     * Returns whether the attachment is filled
     */
    get isFilled() {
        return this.$filled;
    }
    /**
     * Can be attached via string representation
     */
    // eslint-disable-next-line class-methods-use-this
    get canBeAttached() {
        return true;
    }
    /**
     * Checks that the attachment is equivalent with object
     */
    equals(attachment) {
        const target = typeof attachment === 'string'
            ? Attachment.fromString(attachment)
            : attachment;
        return (this.type === target.type
            && this.ownerId === target.ownerId
            && this.id === target.id);
    }
    /**
     * Returns a string to attach a VK
     */
    toString() {
        const accessKey = this.accessKey !== null
            ? `_${this.accessKey}`
            : '';
        return `${this.type}${this.ownerId}_${this.id}${accessKey}`;
    }
    /**
     * Returns data for JSON
     */
    toJSON() {
        return {
            id: this.id,
            ownerId: this.ownerId,
            accessKey: this.accessKey,
            ...this[inspectCustomData]()
        };
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return {
            payload: this.payload
        };
    }
    /**
     * Custom inspect object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [inspect.custom](depth, options) {
        const payload = inspect(this.toJSON(), {
            ...options,
            compact: false
        });
        return `${options.stylize(this.constructor.name, 'special')} <${options.stylize(this, 'string')}> ${payload}`;
    }
}

class ExternalAttachment {
    /**
     * Constructor
     */
    constructor(type, payload) {
        this.type = type;
        this.payload = payload;
        this.$filled = false;
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Returns whether the attachment is filled
     */
    get isFilled() {
        return this.$filled;
    }
    /**
     * Can be attached via string representation
     */
    // eslint-disable-next-line class-methods-use-this
    get canBeAttached() {
        return false;
    }
    /**
     * Returns data for JSON
     */
    toJSON() {
        return this[inspectCustomData]();
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return {
            payload: this.payload
        };
    }
    /**
     * Custom inspect object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [inspect.custom](depth, options) {
        const payload = inspect(this.toJSON(), {
            ...options,
            compact: false
        });
        return `${options.stylize(this.constructor.name, 'special')} ${payload}`;
    }
}

const { POLL } = AttachmentType;
class PollAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(POLL, payload.owner_id, payload.id, payload.access_key);
        // @ts-ignore
        this.vk = vk;
        this.payload = payload;
        this.$filled = 'answers' in payload;
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        // @ts-ignore
        const [poll] = await this.vk.api.polls.getById({
            poll_id: this.id,
            owner_id: this.ownerId
        });
        this.payload = poll;
        if (this.payload.access_key) {
            this.accessKey = this.payload.access_key;
        }
        this.$filled = true;
    }
    /**
     * Checks whether the poll is anonymous
     */
    get isAnonymous() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.anonymous);
    }
    /**
     * Checks whether the poll allows multiple choice of answers
     */
    get isMultiple() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.multiple);
    }
    /**
     * Checks whether the poll is complete
     */
    get isClosed() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.closed);
    }
    /**
     * Check whether questions are attached to the discussion
     */
    get isBoard() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.is_board);
    }
    /**
     * Check if can edit the poll
     */
    get isCanEdit() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.can_edit);
    }
    /**
     * Check if can vote in the survey
     */
    get isCanVote() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.can_vote);
    }
    /**
     * Check if can complain about the poll
     */
    get isCanReport() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.can_report);
    }
    /**
     * Check if can share a survey
     */
    get isCanShare() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.can_share);
    }
    /**
     * Returns the ID of the poll author
     */
    get authorId() {
        return this.payload.author_id || null;
    }
    /**
     * Returns the question text
     */
    get question() {
        return this.payload.question || null;
    }
    /**
     * Returns the date when this poll was created
     */
    get createdAt() {
        return this.payload.created || null;
    }
    /**
     * Returns the end date of the poll in Unixtime. 0, if the poll is unlimited
     */
    get endedAt() {
        if (!this.$filled) {
            return null;
        }
        return this.payload.end_date;
    }
    /**
     * Returns the number of votes
     */
    get votes() {
        return this.payload.votes || null;
    }
    /**
     * Returns the identifiers of the response options selected by the current user
     */
    get answerIds() {
        return this.payload.answer_ids || null;
    }
    /**
     * Returns the identifiers of 3 friends who voted in the poll
     */
    get friends() {
        if (!this.$filled) {
            return null;
        }
        return this.payload.friends || [];
    }
    /**
     * Returns the information about the options for the answer
     */
    get answers() {
        return this.payload.answers || null;
    }
    /**
     * Returns the poll snippet background
     */
    get background() {
        return this.payload.background || null;
    }
    /**
     * Returns a photo - the poll snippet background
     */
    get photo() {
        return this.payload.photo || null;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'authorId',
            'question',
            'createdAt',
            'endedAt',
            'votes',
            'answerIds',
            'friends',
            'answers',
            'background',
            'photo'
        ]);
    }
}

const { GIFT } = AttachmentType;
class GiftAttachment extends ExternalAttachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(GIFT, payload);
        // @ts-ignore
        this.vk = vk;
    }
    /**
     * Returns the identifier gift
     */
    get id() {
        return this.payload.id;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return {
            id: this.id
        };
    }
}

class Attachmentable {
    /**
     * Checks for the presence of attachments
     */
    hasAttachments(type = null) {
        if (type === null) {
            return this.attachments.length > 0;
        }
        return this.attachments.some(attachment => (attachment.type === type));
    }
    getAttachments(type = null) {
        if (type === null) {
            return this.attachments;
        }
        return this.attachments.filter(attachment => (attachment.type === type));
    }
}

// eslint-disable-next-line import/no-cycle
const attachmentsTypes = {
    [AttachmentType.POLL]: () => PollAttachment,
    [AttachmentType.GIFT]: () => GiftAttachment,
    [AttachmentType.WALL]: () => WallAttachment,
    [AttachmentType.LINK]: () => LinkAttachment,
    [AttachmentType.PHOTO]: () => PhotoAttachment,
    [AttachmentType.AUDIO]: () => AudioAttachment,
    [AttachmentType.STORY]: () => StoryAttachment,
    [AttachmentType.VIDEO]: () => VideoAttachment,
    [AttachmentType.DOCUMENT]: () => DocumentAttachment,
    [AttachmentType.MARKET]: () => MarketAttachment,
    [AttachmentType.STICKER]: () => StickerAttachment,
    [AttachmentType.GRAFFITI]: () => GraffitiAttachment,
    [AttachmentType.WALL_REPLY]: () => WallReplyAttachment,
    [AttachmentType.MARKET_ALBUM]: () => MarketAlbumAttachment,
    [AttachmentType.AUDIO_MESSAGE]: () => AudioMessageAttachment
};
/**
 * Transform raw attachments to wrapper
 */
// @ts-ignore
// eslint-disable-next-line import/prefer-default-export, @typescript-eslint/no-explicit-any
const transformAttachments = (attachments = [], vk) => (attachments
    .map((item) => {
    const { type } = item;
    // @ts-ignore
    const attachment = attachmentsTypes[type];
    return attachment
        ? new (attachment())(item[type], vk)
        : false;
})
    .filter(Boolean));

const { WALL } = AttachmentType;
const kAttachments = Symbol('attachments');
const kCopyHistoryAttachments = Symbol('copyHistoryAttachments');
class WallAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(WALL, payload.owner_id || payload.to_id, payload.id, payload.access_key);
        // @ts-ignore
        this.vk = vk;
        this.payload = payload;
        this.$filled = 'date' in payload;
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        const [post] = await this.vk.api.wall.getById({
            posts: `${this.ownerId}_${this.id}`,
            extended: 0
        });
        // @ts-ignore
        this.payload = post;
        this[kAttachments] = null;
        this[kCopyHistoryAttachments] = null;
        if (this.payload.access_key) {
            this.accessKey = this.payload.access_key;
        }
        this.$filled = true;
    }
    /**
     * Checks has comments
     */
    get hasComments() {
        if (!this.$filled) {
            return null;
        }
        const { commentsCount } = this;
        return commentsCount !== null
            ? commentsCount > 0
            : null;
    }
    /**
     * Checks has ads in post
     */
    get hasAds() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.marked_as_ads);
    }
    /**
     * Checks has this user reposted
     */
    get hasUserReposted() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.reposts.user_reposted);
    }
    /**
     * Checks has this user likes
     */
    get hasUserLike() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.likes.user_likes);
    }
    /**
     * Checks can the current user comment on the entry
     */
    get isCanUserCommented() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.comments.can_post);
    }
    /**
     * Checks if a community can comment on a post
     */
    get isCanGroupsCommented() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.comments.groups_can_post);
    }
    /**
     * Checks if you can comment on a post
     */
    get isCanCommented() {
        return this.isCanUserCommented || this.isCanGroupsCommented;
    }
    /**
     * Checks if a user can close on a comments
     */
    get isCanCloseComments() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.comments.can_close);
    }
    /**
     * Checks if a user can open on a comments
     */
    get isCanOpenComments() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.comments.can_open);
    }
    /**
     * Checks whether the current user can like the record
     */
    get isCanLike() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.likes.can_like);
    }
    /**
     * hecks whether the current user can repost the record
     */
    get isCanReposted() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.likes.can_publish);
    }
    /**
     * Checks is can this user pin post
     */
    get isCanPin() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.can_pin);
    }
    /**
     * Checks is can this user delete post
     */
    get isCanDelete() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.can_delete);
    }
    /**
     * Checks is can this user edit post
     */
    get isCanEdit() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.can_edit);
    }
    /**
     * Checks is can this user edit post
     */
    get isPinned() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.is_pinned);
    }
    /**
     * Checks is post created only by friends
     */
    get isFriendsOnly() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.friends_only);
    }
    /**
     * Checks is bookmarked current user
     */
    get isFavorited() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.is_favorite);
    }
    /**
     * Returns the identifier author
     */
    get authorId() {
        return this.payload.from_id || null;
    }
    /**
     * Returns the administrator identifier that posted the entry
     */
    get createdUserId() {
        return this.payload.created_by || null;
    }
    /**
     * The identifier of the record owner, in response to which the current
     */
    get replyOwnerId() {
        return this.payload.reply_owner_id || null;
    }
    /**
     * The identifier of the record in response to which the current one was left.
     */
    get replyPostId() {
        return this.payload.reply_post_id || null;
    }
    /**
     * Returns author identifier if the entry was published
     * on behalf of the community and signed by the user
     */
    get signerId() {
        return this.payload.signer_id || null;
    }
    /**
     * Returns the date when this post was created
     */
    get createdAt() {
        return this.payload.date || null;
    }
    /**
     * Returns the post type
     */
    get postType() {
        return this.payload.post_type || null;
    }
    /**
     * Returns the post text
     */
    get text() {
        return this.payload.text || null;
    }
    /**
     * Returns the number of record views
     */
    get viewsCount() {
        if (!this.$filled) {
            return null;
        }
        return 'views' in this.payload
            ? this.payload.views.count
            : null;
    }
    /**
     * Returns the likes count
     */
    get likesCount() {
        if (!this.$filled) {
            return null;
        }
        return 'likes' in this.payload
            ? this.payload.likes.count
            : null;
    }
    /**
     * Returns the reposts count
     */
    get repostsCount() {
        if (!this.$filled) {
            return null;
        }
        return 'reposts' in this.payload
            ? this.payload.reposts.count
            : null;
    }
    /**
     * Returns the comments count
     */
    get commentsCount() {
        if (!this.$filled) {
            return null;
        }
        return 'comments' in this.payload
            ? this.payload.comments.count
            : null;
    }
    /**
     * Returns the likes info
     */
    get likes() {
        return this.payload.likes || null;
    }
    /**
     * Returns the post source
     */
    get postSource() {
        return this.payload.post_source || null;
    }
    /**
     * Returns the geo location
     */
    get geo() {
        return this.payload.geo || null;
    }
    /**
     * Returns the history of reposts for post
     */
    get copyHistory() {
        if (!this[kCopyHistoryAttachments]) {
            this[kCopyHistoryAttachments] = this.payload.copy_history
                ? this.payload.copy_history.map((history) => (new WallAttachment(history, this.vk)))
                : [];
        }
        return this[kCopyHistoryAttachments];
    }
    /**
     * Returns the attachments
     */
    get attachments() {
        if (!this[kAttachments]) {
            this[kAttachments] = transformAttachments(this.payload.attachments || [], this.vk);
        }
        return this[kAttachments];
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'authorId',
            'createdUserId',
            'replyOwnerId',
            'replyPostId',
            'signerId',
            'createdAt',
            'postType',
            'text',
            'viewsCount',
            'likesCount',
            'repostsCount',
            'commentsCount',
            'likes',
            'postSource',
            'geo',
            'copyHistory',
            'attachments'
        ]);
    }
}
applyMixins(WallAttachment, [Attachmentable]);

const { PHOTO } = AttachmentType;
const SMALL_SIZES = ['m', 's'];
const MEDIUM_SIZES = ['y', 'r', 'q', 'p', ...SMALL_SIZES];
const LARGE_SIZES = ['w', 'z', ...MEDIUM_SIZES];
class PhotoAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(PHOTO, payload.owner_id, payload.id, payload.access_key);
        // @ts-ignore
        this.vk = vk;
        this.payload = payload;
        this.$filled = 'album_id' in payload && 'date' in payload;
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        const [photo] = await this.vk.api.photos.getById({
            photos: `${this.ownerId}_${this.id}`,
            extended: 0
        });
        // @ts-ignore
        this.payload = photo;
        if (this.payload.access_key) {
            this.accessKey = this.payload.access_key;
        }
        this.$filled = true;
    }
    /**
     * Returns the ID of the user who uploaded the image
     */
    get userId() {
        return this.payload.user_id || null;
    }
    /**
     * Returns the ID of the album
     */
    get albumId() {
        return this.payload.album_id || null;
    }
    /**
     * Returns the photo text
     */
    get text() {
        return this.payload.text || null;
    }
    /**
     * Returns the date when this photo was created
     */
    get createdAt() {
        return this.payload.date || null;
    }
    /**
     * Returns the photo height
     */
    get height() {
        return this.payload.height || null;
    }
    /**
     * Returns the photo width
     */
    get width() {
        return this.payload.width || null;
    }
    /**
     * Returns the URL of a small photo
     * (130 or 75)
     */
    get smallPhoto() {
        if (!this.$filled) {
            return null;
        }
        const [size] = this.getSizes(SMALL_SIZES);
        return size.url;
    }
    /**
     * Returns the URL of a medium photo
     * (807 or 604 or less)
     */
    get mediumPhoto() {
        if (!this.$filled) {
            return null;
        }
        const [size] = this.getSizes(MEDIUM_SIZES);
        return size.url;
    }
    /**
     * Returns the URL of a large photo
     * (2560 or 1280 or less)
     */
    get largePhoto() {
        if (!this.$filled) {
            return null;
        }
        const [size] = this.getSizes(LARGE_SIZES);
        return size.url;
    }
    /**
     * Returns the sizes
     */
    get sizes() {
        return this.payload.sizes || null;
    }
    /**
     * Returns the sizes of the required types
     */
    getSizes(sizeTypes) {
        const { sizes } = this;
        if (!sizes) {
            return [];
        }
        // @ts-ignore
        return sizeTypes
            .map((sizeType) => (sizes.find((size) => size.type === sizeType) || null))
            .filter(Boolean);
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'userId',
            'albumId',
            'text',
            'createdAt',
            'height',
            'width',
            'smallPhoto',
            'mediumPhoto',
            'largePhoto',
            'sizes'
        ]);
    }
}

const { LINK } = AttachmentType;
const kPhoto = Symbol('kPhoto');
class LinkAttachment extends ExternalAttachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(LINK, payload);
        // @ts-ignore
        this.vk = vk;
    }
    /**
     * Checks for the presence of a photo in a link
     */
    get hasPhoto() {
        return Boolean(this[kPhoto]);
    }
    /**
     * Returns the title
     */
    get title() {
        return this.payload.title;
    }
    /**
     * Returns the title
     */
    get caption() {
        return this.payload.caption || null;
    }
    /**
     * Returns the description
     */
    get description() {
        return this.payload.description || null;
    }
    /**
     * Returns the URL of the link
     */
    get url() {
        return this.payload.url;
    }
    /**
     * Returns the product
     */
    get product() {
        return this.payload.product;
    }
    /**
     * Returns the button
     */
    get button() {
        return this.payload.button || null;
    }
    /**
     * Returns the photo
     */
    get photo() {
        if (!this[kPhoto]) {
            this[kPhoto] = this.payload.photo
                ? new PhotoAttachment(this.payload.photo, this.vk)
                : null;
        }
        return this[kPhoto];
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'title',
            'caption',
            'description',
            'url',
            'product',
            'button',
            'photo'
        ]);
    }
}

const { AUDIO } = AttachmentType;
class AudioAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(AUDIO, payload.owner_id, payload.id, payload.access_key);
        // @ts-ignore
        this.vk = vk;
        this.payload = payload;
        this.$filled = 'duration' in payload && 'date' in payload;
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        // @ts-ignore
        const [audio] = await this.vk.api.audio.getById({
            audios: `${this.ownerId}_${this.id}`
        });
        this.payload = audio;
        if (this.payload.access_key) {
            this.accessKey = this.payload.access_key;
        }
        this.$filled = true;
    }
    /**
     * Checks whether audio is in high quality
     */
    get isHq() {
        const { is_hq: isHq } = this.payload;
        if (isHq === undefined) {
            return null;
        }
        return isHq === 1;
    }
    /**
     * Returns the ID of the lyric
     */
    get lyricsId() {
        return this.payload.lyrics_id || null;
    }
    /**
     * Returns the ID of the album
     */
    get albumId() {
        return this.payload.album_id || null;
    }
    /**
     * Returns the ID of the genre
     */
    get genreId() {
        return this.payload.genre_id || null;
    }
    /**
     * Returns the title
     */
    get title() {
        return this.payload.title || null;
    }
    /**
     * Returns the artist
     */
    get artist() {
        return this.payload.artist || null;
    }
    /**
     * Returns the duration
     */
    get duration() {
        if (!this.$filled) {
            return null;
        }
        return this.payload.duration;
    }
    /**
     * Returns the date object when this audio was created
     */
    get createdAt() {
        return this.payload.date || null;
    }
    /**
     * Returns the URL of the audio
     */
    get url() {
        return this.payload.url || null;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'lyricsId',
            'albumId',
            'genreId',
            'title',
            'artist',
            'duration',
            'createdAt',
            'url'
        ]);
    }
}

const { VIDEO } = AttachmentType;
class VideoAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(VIDEO, payload.owner_id, payload.id, payload.access_key);
        // @ts-ignore
        this.vk = vk;
        this.payload = payload;
        this.$filled = 'date' in payload;
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        const { items } = await this.vk.api.video.get({
            videos: `${this.ownerId}_${this.id}`,
            extended: 0
        });
        const [video] = items;
        // @ts-ignore
        this.payload = video;
        if (this.payload.access_key) {
            this.accessKey = this.payload.access_key;
        }
        this.$filled = true;
    }
    /**
     * Checks whether the video is repeatable
     */
    get isRepeat() {
        return this.checkBooleanInProperty('repeat');
    }
    /**
     * Checks that the user can add a video to himself
     */
    get isCanAdd() {
        return this.checkBooleanInProperty('can_add');
    }
    /**
     * Checks if the user can edit the video
     */
    get isCanEdit() {
        return this.checkBooleanInProperty('can_edit');
    }
    /**
     * Checks whether the video is being processed
     */
    get isProcessing() {
        return this.checkBooleanInProperty('processing');
    }
    /**
     * Checks whether the video is a broadcast
     */
    get isBroadcast() {
        return this.checkBooleanInProperty('live');
    }
    /**
     * Checks whether the video is a broadcast
     */
    get isUpcoming() {
        return this.checkBooleanInProperty('upcoming');
    }
    /**
     * Checks is bookmarked current user
     */
    get isFavorited() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.is_favorite);
    }
    /**
     * Returns the title
     */
    get title() {
        return this.payload.title || null;
    }
    /**
     * Returns the description
     */
    get description() {
        return this.payload.description || null;
    }
    /**
     * Returns the duration
     */
    get duration() {
        if (!this.$filled) {
            return null;
        }
        return this.payload.duration;
    }
    /**
     * Returns the date when this video was created
     */
    get createdAt() {
        return this.payload.date || null;
    }
    /**
     * Returns the date when this video was added
     */
    get addedAt() {
        return this.payload.adding_date || null;
    }
    /**
     * Returns the count views
     */
    get viewsCount() {
        return this.payload.views || null;
    }
    /**
     * Returns the count comments
     */
    get commentsCount() {
        return this.payload.comments || null;
    }
    /**
     * Returns the URL of the page with the player
     */
    get player() {
        return this.payload.player || null;
    }
    /**
     * Returns the name of the platform (for video recordings added from external sites)
     */
    get platformName() {
        return this.payload.platform || null;
    }
    /**
     * Checks for a boolean value in the property
     */
    checkBooleanInProperty(name) {
        // @ts-ignore
        const property = this.payload[name];
        if (typeof property !== 'number') {
            return null;
        }
        return property === 1;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'title',
            'description',
            'duration',
            'createdAt',
            'addedAt',
            'viewsCount',
            'commentsCount',
            'player',
            'platformName'
        ]);
    }
}

const { STORY } = AttachmentType;
const kVideo = Symbol('video');
const kPhoto$1 = Symbol('photo');
const kParentStory = Symbol('parentStory');
class StoryAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(STORY, payload.owner_id, payload.id, payload.access_key);
        // @ts-ignore
        this.vk = vk;
        this.payload = payload;
        this.$filled = 'is_deleted' in payload || 'is_expired' in payload;
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        // @ts-ignore
        const [story] = await this.vk.api.stories.getById({
            stories: `${this.ownerId}_${this.id}`,
            extended: 0
        });
        this.payload = story;
        if (this.payload.access_key) {
            this.accessKey = this.payload.access_key;
        }
        this.$filled = true;
    }
    /**
     * Checks is story expired
     */
    get isExpired() {
        return this.payload.is_expired;
    }
    /**
     * Checks is story deleted
     */
    get isDeleted() {
        return this.payload.is_deleted;
    }
    /**
     * Checks is story viewed by current user
     */
    get isSeen() {
        if (!this.$filled) {
            return undefined;
        }
        return this.payload.seen === 1;
    }
    /**
     * Checks can story reply
     */
    get isCanReply() {
        if (!this.$filled) {
            return undefined;
        }
        return this.payload.can_reply === 1;
    }
    /**
     * Checks can story share
     */
    get isCanShare() {
        if (!this.$filled) {
            return undefined;
        }
        return this.payload.can_share === 1;
    }
    /**
     * Checks can story comment
     */
    get isCanComment() {
        if (!this.$filled) {
            return undefined;
        }
        return this.payload.can_comment === 1;
    }
    /**
     * Returns the type of story
     */
    get storyType() {
        return this.payload.type;
    }
    /**
     * Returns the story photo
     */
    get photo() {
        if (!this.$filled) {
            return undefined;
        }
        if (!this[kPhoto$1]) {
            this[kPhoto$1] = new PhotoAttachment(this.payload.photo, this.vk);
        }
        return this[kPhoto$1];
    }
    /**
     * Returns the story video
     */
    get video() {
        if (!this.$filled) {
            return undefined;
        }
        if (!this[kVideo]) {
            this[kVideo] = new VideoAttachment(this.payload.video, this.vk);
        }
        return this[kVideo];
    }
    /**
     * Returns the date when this story was created
     */
    get createdAt() {
        return this.payload.date;
    }
    /**
     * Returns the date when this story was expires
     */
    get expiresAt() {
        return this.payload.expires_at;
    }
    /**
     * Returns the story views count
     */
    get viewsCount() {
        return this.payload.views;
    }
    /**
     * Returns the story link
     */
    get link() {
        return this.payload.link;
    }
    /**
     * Returns the story replies
     */
    get replies() {
        return this.payload.replies;
    }
    /**
     * Returns the parent story id
     */
    get parentStoryId() {
        return this.payload.parent_story_id;
    }
    /**
     * Returns the parent story owner id
     */
    get parentStoryOwnerId() {
        return this.payload.parent_story_owner_id;
    }
    /**
     * Returns the parent story
     */
    get parentStory() {
        if (!this.$filled) {
            return undefined;
        }
        if (!this[kParentStory]) {
            this[kParentStory] = new StoryAttachment(this.payload.parent_story, this.vk);
        }
        return this[kParentStory];
    }
    /**
     * Returns the parent story clickable stickers
     */
    get clickableStickers() {
        return this.payload.clickable_stickers;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        if (this.isDeleted) {
            return copyParams(this, [
                'isDeleted'
            ]);
        }
        if (this.isExpired) {
            return copyParams(this, [
                'isExpired',
                'expiresAt'
            ]);
        }
        return copyParams(this, [
            'isExpired',
            'isDeleted',
            'isSeen',
            'isCanReply',
            'isCanShare',
            'isCanComment',
            'storyType',
            'photo',
            'video',
            'createdAt',
            'expiresAt',
            'viewsCount',
            'link',
            'replies',
            'parentStoryId',
            'parentStoryOwnerId',
            'parentStory',
            'clickableStickers'
        ]);
    }
}

const { MARKET } = AttachmentType;
class MarketAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(MARKET, payload.owner_id, payload.id, payload.access_key);
        // @ts-ignore
        this.vk = vk;
        this.payload = payload;
        this.$filled = 'title' in payload && 'date' in payload;
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        // @ts-ignore
        const [market] = await this.vk.api.market.getById({
            item_ids: `${this.ownerId}_${this.id}`,
            extended: 0
        });
        this.payload = market;
        if (this.payload.access_key) {
            this.accessKey = this.payload.access_key;
        }
        this.$filled = true;
    }
    /**
     * Checks is bookmarked current user
     */
    get isFavorited() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.is_favorite);
    }
}

const { STICKER } = AttachmentType;
class StickerAttachment extends ExternalAttachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(STICKER, payload);
        // @ts-ignore
        this.vk = vk;
    }
    /**
     * Returns the identifier sticker
     */
    get id() {
        return this.payload.sticker_id;
    }
    /**
     * Returns the identifier product
     */
    get productId() {
        return this.payload.product_id;
    }
    /**
     * Returns the images sizes
     */
    get images() {
        return this.payload.images || [];
    }
    /**
     * Returns the images sizes with backgrounds
     */
    get imagesWithBackground() {
        return this.payload.images_with_background || [];
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'id',
            'productId',
            'images',
            'imagesWithBackground'
        ]);
    }
}

const { GRAFFITI } = AttachmentType;
class GraffitiAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(GRAFFITI, payload.owner_id, payload.id, payload.access_key);
        // @ts-ignore
        this.vk = vk;
        this.payload = payload;
        this.$filled = 'url' in payload;
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        const [document] = await this.vk.api.docs.getById({
            docs: `${this.ownerId}_${this.id}`
        });
        // @ts-ignore
        this.payload = document;
        if (this.payload.access_key) {
            this.accessKey = this.payload.access_key;
        }
        this.$filled = true;
    }
    /**
     * Returns the graffiti height
     */
    get height() {
        return this.payload.height || null;
    }
    /**
     * Returns the graffiti width
     */
    get width() {
        return this.payload.width || null;
    }
    /**
     * Returns the URL of the document
     */
    get url() {
        return this.payload.url || null;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'height',
            'width',
            'url'
        ]);
    }
}

const { DOCUMENT } = AttachmentType;
/**
 * Types of documents
 */
const documentTypes = new Map([
    [1, 'text'],
    [2, 'archive'],
    [3, 'gif'],
    [4, 'image'],
    [5, 'audio'],
    [6, 'video'],
    [7, 'book'],
    [8, 'unknown']
]);
class DocumentAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(DOCUMENT, payload.owner_id, payload.id, payload.access_key);
        // @ts-ignore
        this.vk = vk;
        this.payload = payload;
        this.$filled = 'ext' in payload && 'date' in payload;
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        const [document] = await this.vk.api.docs.getById({
            docs: `${this.ownerId}_${this.id}`
        });
        // @ts-ignore
        this.payload = document;
        if (this.payload.access_key) {
            this.accessKey = this.payload.access_key;
        }
        this.$filled = true;
    }
    /**
     * Checks if the document is a text
     */
    get isText() {
        if (!this.$filled) {
            return null;
        }
        return this.typeId === 1;
    }
    /**
     * Checks if the document is a archive
     */
    get isArchive() {
        if (!this.$filled) {
            return null;
        }
        return this.typeId === 2;
    }
    /**
     * Checks if the document is a gif file
     */
    get isGif() {
        if (!this.$filled) {
            return null;
        }
        return this.typeId === 3;
    }
    /**
     * Checks if the document is a image
     */
    get isImage() {
        if (!this.$filled) {
            return null;
        }
        return this.typeId === 4;
    }
    /**
     * Checks if the document is a graffiti
     */
    get isGraffiti() {
        if (!this.$filled) {
            return null;
        }
        return this.hasPreviewProperty('graffiti');
    }
    /**
     * Checks if the document is a audio
     */
    get isAudio() {
        if (!this.$filled) {
            return null;
        }
        return this.typeId === 5;
    }
    /**
     * Checks if the document is a voice
     */
    get isVoice() {
        if (!this.$filled) {
            return null;
        }
        return this.hasPreviewProperty('audio_msg');
    }
    /**
     * Checks if the document is a video
     */
    get isVideo() {
        if (!this.$filled) {
            return null;
        }
        return this.typeId === 6;
    }
    /**
     * Checks if the document is a book
     */
    get isBook() {
        if (!this.$filled) {
            return null;
        }
        return this.typeId === 7;
    }
    /**
     * Returns the document title
     */
    get title() {
        return this.payload.title || null;
    }
    /**
     * Returns the date when this document was created
     */
    get createdAt() {
        return this.payload.date || null;
    }
    /**
     * Returns the type identifier (1~8)
     */
    get typeId() {
        return this.payload.type || null;
    }
    /**
     * Returns the type name
     */
    get typeName() {
        if (!this.$filled) {
            return null;
        }
        return documentTypes.get(this.typeId);
    }
    /**
     * Returns the size in bytes
     */
    get size() {
        if (!this.$filled) {
            return null;
        }
        return this.payload.size;
    }
    /**
     * Returns the extension
     */
    get extension() {
        return this.payload.ext || null;
    }
    /**
     * Returns the URL of the document
     */
    get url() {
        return this.payload.url || null;
    }
    /**
     * Returns the info to preview
     */
    get preview() {
        return this.payload.preview || null;
    }
    /**
     * Checks for a property in preview
     */
    hasPreviewProperty(name) {
        const { preview } = this;
        if (preview === null) {
            return false;
        }
        return name in preview;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'title',
            'typeId',
            'typeName',
            'createdAt',
            'extension',
            'url'
        ]);
    }
}

const { WALL_REPLY } = AttachmentType;
class WallReplyAttachment extends ExternalAttachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(WALL_REPLY, payload);
        // @ts-ignore
        this.vk = vk;
    }
}

const { MARKET_ALBUM } = AttachmentType;
class MarketAlbumAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(MARKET_ALBUM, payload.owner_id, payload.id, payload.access_key);
        // @ts-ignore
        this.vk = vk;
        this.payload = payload;
        this.$filled = 'title' in payload && 'updated_time' in payload;
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        // @ts-ignore
        const [album] = await this.vk.api.market.getAlbumById({
            owner_id: this.ownerId,
            album_ids: this.id
        });
        this.payload = album;
        if (this.payload.access_key) {
            this.accessKey = this.payload.access_key;
        }
        this.$filled = true;
    }
}

const { AUDIO_MESSAGE } = AttachmentType;
class AudioMessageAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(AUDIO_MESSAGE, payload.owner_id, payload.id, payload.access_key);
        // @ts-ignore
        this.vk = vk;
        this.payload = payload;
        this.$filled = 'duration' in payload;
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        const [document] = await this.vk.api.docs.getById({
            docs: `${this.ownerId}_${this.id}`
        });
        // @ts-ignore
        this.payload = document;
        if (this.payload.access_key) {
            this.accessKey = this.payload.access_key;
        }
        this.$filled = true;
    }
    /**
     * Returns the duration of the audio message
     */
    get duration() {
        if (!this.$filled) {
            return null;
        }
        return this.payload.duration;
    }
    /**
     * Returns the waveform of the audio message
     */
    get waveform() {
        return this.payload.waveform || null;
    }
    /**
     * Returns the ogg URL of the audio message
     */
    get oggUrl() {
        return this.payload.link_ogg || null;
    }
    /**
     * Returns the mp3 URL of the audio message
     */
    get mp3Url() {
        return this.payload.link_mp3 || null;
    }
    /**
     * Returns the URL of the audio message
     */
    get url() {
        return this.mp3Url || this.oggUrl;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        const payload = copyParams(this, [
            'duration',
            'waveform',
            'oggUrl',
            'mp3Url',
            'url'
        ]);
        // @ts-ignore
        payload.waveform = `[...${this.waveform.length} elements]`;
        return payload;
    }
}

const { MISSING_PARAMETERS, NO_FILES_TO_UPLOAD, EXCEEDED_MAX_FILES, UNSUPPORTED_SOURCE_TYPE } = UploadErrorCode;
const isURL = /^https?:\/\//i;
const DocumentTypes = {
    doc: DocumentAttachment,
    graffiti: GraffitiAttachment,
    audio_message: AudioMessageAttachment
};
class Upload {
    /**
     * Constructor
     */
    constructor(vk) {
        this.vk = vk;
        this.graffiti = deprecate(params => (
        // @ts-ignore
        this.messageGraffiti(params)), 'graffiti(params) is deprecated, use messageGraffiti(params) instead');
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Uploading photos to an album
     */
    async photoAlbum(params) {
        const photos = await this.conduct({
            field: 'file',
            params,
            // @ts-ignore
            getServer: this.vk.api.photos.getUploadServer,
            serverParams: ['album_id', 'group_id'],
            saveFiles: this.vk.api.photos.save,
            saveParams: ['album_id', 'group_id', 'latitude', 'longitude', 'caption'],
            maxFiles: 5,
            attachmentType: 'photo'
        });
        // @ts-ignore
        return photos.map(photo => (new PhotoAttachment(photo, this.vk)));
    }
    /**
     * Uploading photos to the wall
     */
    async wallPhoto(params) {
        const [photo] = await this.conduct({
            field: 'photo',
            params,
            // @ts-ignore
            getServer: this.vk.api.photos.getWallUploadServer,
            serverParams: ['group_id'],
            // @ts-ignore
            saveFiles: this.vk.api.photos.saveWallPhoto,
            saveParams: ['user_id', 'group_id', 'latitude', 'longitude', 'caption'],
            maxFiles: 1,
            attachmentType: 'photo'
        });
        return new PhotoAttachment(photo, this.vk);
    }
    /**
     * Uploading the main photo of a user or community
     */
    ownerPhoto(params) {
        return this.conduct({
            field: 'photo',
            params,
            // @ts-ignore
            getServer: this.vk.api.photos.getOwnerPhotoUploadServer,
            serverParams: ['owner_id'],
            saveFiles: this.vk.api.photos.saveOwnerPhoto,
            maxFiles: 1,
            attachmentType: 'photo'
        });
        // {
        //   photo_hash: 'c8d43da5e1281b7aed6bb8f0c4f3ad69',
        //   photo_src: 'https://pp.userapi.com/c836429/v836429114/673f6/5VJB8GXtK88.jpg',
        //   photo_src_big: 'https://pp.userapi.com/c836429/v836429114/673f7/7fGvrJ1wOx0.jpg',
        //   photo_src_small: 'https://pp.userapi.com/c836429/v836429114/673f5/l5d1ASgyuxk.jpg',
        //   saved: 1,
        //   post_id: 3331
        // }
    }
    /**
     * Uploading a photo to a private message
     */
    async messagePhoto(params) {
        const [photo] = await this.conduct({
            field: 'photo',
            params,
            // @ts-ignore
            getServer: this.vk.api.photos.getMessagesUploadServer,
            serverParams: ['peer_id'],
            // @ts-ignore
            saveFiles: this.vk.api.photos.saveMessagesPhoto,
            maxFiles: 1,
            attachmentType: 'photo'
        });
        return new PhotoAttachment(photo, this.vk);
    }
    /**
     * Uploading the main photo for a chat
     */
    chatPhoto(params) {
        return this.conduct({
            field: 'file',
            params,
            // @ts-ignore
            getServer: this.vk.api.photos.getChatUploadServer,
            serverParams: ['chat_id', 'crop_x', 'crop_y', 'crop_width'],
            saveFiles: file => (
            // @ts-ignore
            this.vk.api.messages.setChatPhoto({ file })),
            maxFiles: 1,
            attachmentType: 'photo'
        });
        // {
        //   message_id: 3745390,
        //   chat: {
        //    id: 152,
        //    type: 'chat',
        //    title: '<Titile name>',
        //    admin_id: 335447860,
        //    users: [335447860,
        //      140192020,
        //      153711615,
        //      314650825,
        //      218747758,
        //      155944103,
        //      159737827,
        //      64299368,
        //      157534541,
        //      153608064,
        //      335540121,
        //      349609849,
        //      344184938,
        //      341178526,
        //      198210835,
        //      135446999,
        //      163850606,
        //      123640861,
        //      316216798,
        //      359118107,
        //      241235369,
        //      160213445,
        //      126624591,
        //      390221395,
        //      195624402,
        //      94955334,
        //      167302501,
        //      17516523,
        //      294583792,
        //      294869767,
        //      114281676,
        //      137762280,
        //      406076540,
        //      410605840,
        //      395646590,
        //      421554042,
        //      331599090,
        //      342269712
        //    ],
        //    photo_50: 'https://pp.userapi.com/c837624/v837624114/5d495/gLgv-JrVmkk.jpg',
        //    photo_100: 'https://pp.userapi.com/c837624/v837624114/5d494/VNp61I1yuCk.jpg',
        //    photo_200: 'https://pp.userapi.com/c837624/v837624114/5d492/lAoc_fAai2Q.jpg'
        //   }
        // }
    }
    /**
     * Uploading a photo for a product
     */
    async marketPhoto(params) {
        const [photo] = await this.conduct({
            field: 'file',
            params,
            // @ts-ignore
            getServer: this.vk.api.photos.getMarketUploadServer,
            serverParams: ['group_id', 'main_photo', 'crop_x', 'crop_y', 'crop_width'],
            // @ts-ignore
            saveFiles: this.vk.api.photos.saveMarketPhoto,
            saveParams: ['group_id'],
            maxFiles: 1,
            attachmentType: 'photo'
        });
        return new PhotoAttachment(photo, this.vk);
    }
    /**
     * Uploads a photo for the selection of goods
     */
    async marketAlbumPhoto(params) {
        const [photo] = await this.conduct({
            field: 'file',
            params,
            // @ts-ignore
            getServer: this.vk.api.photos.getMarketAlbumUploadServer,
            serverParams: ['group_id'],
            // @ts-ignore
            saveFiles: this.vk.api.photos.saveMarketAlbumPhoto,
            saveParams: ['group_id'],
            maxFiles: 1,
            attachmentType: 'photo'
        });
        return new PhotoAttachment(photo, this.vk);
    }
    /**
     * Uploads audio
     */
    async audio(params) {
        const audio = await this.conduct({
            field: 'file',
            params,
            // @ts-ignore
            getServer: this.vk.api.audio.getUploadServer,
            // @ts-ignore
            saveFiles: this.vk.api.audio.save,
            saveParams: ['title', 'artist'],
            maxFiles: 1,
            attachmentType: 'audio'
        });
        return new AudioAttachment(audio, this.vk);
    }
    /**
     * Uploads video
     */
    async video(params) {
        const save = await this.vk.api.video.save(copyParams$1(params, [
            'group_id',
            'album_id',
            'link',
            'name',
            'description',
            'is_private',
            'wallpost',
            'privacy_view',
            'privacy_comment',
            'no_comments',
            'repeat',
            'compression'
        ]));
        save.id = save.video_id;
        if ('link' in params) {
            const response = await fetch(save.upload_url, {
                agent: this.vk.options.agent
            });
            await response.json();
            // @ts-ignore
            return new VideoAttachment(save, this.vk);
        }
        let { source } = params;
        if (typeof source !== 'object' || source.constructor !== Object) {
            // @ts-ignore
            source = {
                values: source
            };
        }
        // @ts-ignore
        if (!Array.isArray(source.values)) {
            // @ts-ignore
            source.values = [source.values];
        }
        const formData = await this.buildPayload({
            maxFiles: 1,
            field: 'video_file',
            attachmentType: 'video',
            // @ts-ignore
            values: source.values
        });
        const video = await this.upload(save.upload_url, {
            formData,
            forceBuffer: true,
            // @ts-ignore
            timeout: source.timeout
        });
        return new VideoAttachment({ ...save, ...video }, this.vk);
    }
    /**
     * Uploads document
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async conductDocument(params, { attachmentType = 'doc' } = {}) {
        const response = await this.conduct({
            field: 'file',
            params,
            // @ts-ignore
            getServer: this.vk.api.docs.getUploadServer,
            serverParams: ['type', 'group_id'],
            // @ts-ignore
            saveFiles: this.vk.api.docs.save,
            saveParams: ['title', 'tags'],
            maxFiles: 1,
            attachmentType
        });
        const ConductAttachment = DocumentTypes[response.type] || DocumentTypes.doc;
        return new ConductAttachment(response[response.type], this.vk);
    }
    /**
     * Uploads document
     */
    document(params) {
        return this.conductDocument(params, {
            attachmentType: 'doc'
        });
    }
    /**
     * Uploads wall document
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async conductWallDocument(params, { attachmentType = 'doc' } = {}) {
        const response = await this.conduct({
            field: 'file',
            params,
            // @ts-ignore
            getServer: this.vk.api.docs.getWallUploadServer,
            serverParams: ['type', 'group_id'],
            // @ts-ignore
            saveFiles: this.vk.api.docs.save,
            saveParams: ['title', 'tags'],
            maxFiles: 1,
            attachmentType
        });
        const ConductAttachment = DocumentTypes[response.type] || DocumentTypes.doc;
        return new ConductAttachment(response[response.type], this.vk);
    }
    /**
     * Uploads wall document
     */
    wallDocument(params) {
        return this.conductWallDocument(params, {
            attachmentType: 'doc'
        });
    }
    /**
     * Uploads wall document
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async conductMessageDocument(params, { attachmentType = 'doc' } = {}) {
        const response = await this.conduct({
            field: 'file',
            params,
            // @ts-ignore
            getServer: this.vk.api.docs.getMessagesUploadServer,
            serverParams: ['type', 'peer_id'],
            // @ts-ignore
            saveFiles: this.vk.api.docs.save,
            saveParams: ['title', 'tags'],
            maxFiles: 1,
            attachmentType
        });
        const ConductAttachment = DocumentTypes[response.type] || DocumentTypes.doc;
        return new ConductAttachment(response[response.type], this.vk);
    }
    /**
     * Uploads message document
     */
    messageDocument(params) {
        return this.conductMessageDocument({
            ...params,
            type: 'doc'
        }, {
            attachmentType: 'doc'
        });
    }
    /**
     * Uploads audio message
     */
    audioMessage(params) {
        return this.conductMessageDocument({
            ...params,
            type: 'audio_message'
        }, {
            attachmentType: 'audioMessage'
        });
        // { type: 'audio_message',
        // audio_message: {
        //   id: 484017542,
        //   owner_id: 195624402,
        //   duration: 48,
        //   waveform: [...],
        //   link_ogg:
        //   'https://psv4.userapi.com/c805324//u195624402/audiomsg/15734aa6bb.ogg',
        //   link_mp3:
        //   'https://psv4.userapi.com/c805324//u195624402/audiomsg/15734aa6bb.mp3',
        //   access_key: '295cc90411e6222db0' } }
    }
    /**
     * Uploads graffiti in documents
     */
    documentGraffiti(params) {
        return this.conductDocument({
            ...params,
            type: 'graffiti'
        }, {
            attachmentType: 'graffiti'
        });
    }
    /**
     * Uploads graffiti in messages
     */
    messageGraffiti(params) {
        return this.conductMessageDocument({
            ...params,
            type: 'graffiti'
        }, {
            attachmentType: 'graffiti'
        });
    }
    /**
     * Uploads community cover
     */
    groupCover(params) {
        return this.conduct({
            field: 'photo',
            params,
            // @ts-ignore
            getServer: this.vk.api.photos.getOwnerCoverPhotoUploadServer,
            serverParams: ['group_id', 'crop_x', 'crop_y', 'crop_x2', 'crop_y2'],
            // @ts-ignore
            saveFiles: this.vk.api.photos.saveOwnerCoverPhoto,
            maxFiles: 1,
            attachmentType: 'photo'
        });
        // {
        //  images: [
        //    {
        //      url: 'https://cs7056.userapi.com/c639526/v639526192/46404/r-1Nhr-Dktc.jpg',
        //      width: 200,
        //      height: 50
        //    },
        //    {
        //      url: 'https://cs7056.userapi.com/c639526/v639526192/46403/oDB9tAgtUrQ.jpg',
        //      width: 400,
        //      height: 101
        //    },
        //    {
        //      url: 'https://cs7056.userapi.com/c639526/v639526192/46400/gLwCTmDEPXY.jpg',
        //      width: 795,
        //      height: 200
        //    },
        //    {
        //      url: 'https://cs7056.userapi.com/c639526/v639526192/46402/w2ucyq8zwF8.jpg',
        //      width: 1080,
        //      height: 272
        //    },
        //    {
        //      url: 'https://cs7056.userapi.com/c639526/v639526192/46401/YTmN89yMaU0.jpg',
        //      width: 1590,
        //      height: 400
        //    }
        //  ]
        // }
    }
    /**
     * Uploads photo stories
     */
    storiesPhoto(params) {
        return this.conduct({
            field: 'file',
            params,
            // @ts-ignore
            getServer: this.vk.api.stories.getPhotoUploadServer,
            serverParams: [
                'add_to_news',
                'user_ids',
                'reply_to_story',
                'link_text',
                'link_url',
                'group_id',
                'attach_access_key'
            ],
            saveFiles: save => save,
            maxFiles: 1,
            attachmentType: 'photo'
        });
    }
    /**
     * Uploads video stories
     */
    storiesVideo(params) {
        return this.conduct({
            field: 'video_file',
            params,
            // @ts-ignore
            getServer: this.vk.api.stories.getVideoUploadServer,
            serverParams: [
                'add_to_news',
                'user_ids',
                'reply_to_story',
                'link_text',
                'link_url',
                'group_id'
            ],
            saveFiles: save => save,
            maxFiles: 1,
            attachmentType: 'video',
            forceBuffer: true
        });
    }
    /**
     * Uploads poll photo
     */
    pollPhoto(params
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ) {
        return this.conduct({
            field: 'file',
            params,
            // @ts-ignore
            getServer: this.vk.api.polls.getPhotoUploadServer,
            serverParams: ['owner_id'],
            // @ts-ignore
            saveFiles: this.vk.api.polls.savePhoto,
            maxFiles: 1,
            attachmentType: 'photo'
        });
    }
    /**
     * Behavior for the upload method
     */
    async conduct({ field, params, getServer, serverParams = [], saveFiles, saveParams = [], maxFiles = 1, attachmentType, forceBuffer = false
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
     }) {
        if (!params || !params.source) {
            throw new UploadError({
                message: 'Missing upload params',
                code: MISSING_PARAMETERS
            });
        }
        let { source } = params;
        if (typeof source !== 'object'
            || source.constructor !== Object
            // @ts-ignore
            || source.value !== undefined) {
            // @ts-ignore
            source = {
                values: source
            };
        }
        // @ts-ignore
        if (!Array.isArray(source.values)) {
            // @ts-ignore
            source.values = [source.values];
        }
        // @ts-ignore
        if ('uploadUrl' in source) {
            // eslint-disable-next-line no-param-reassign
            getServer = () => ({
                // @ts-ignore
                upload_url: source.uploadUrl
            });
        }
        // @ts-ignore
        const { length: valuesLength } = source.values;
        if (valuesLength === 0) {
            throw new UploadError({
                message: 'No files to upload',
                code: NO_FILES_TO_UPLOAD
            });
        }
        if (valuesLength > maxFiles) {
            throw new UploadError({
                message: 'The number of files uploaded has exceeded',
                code: EXCEEDED_MAX_FILES
            });
        }
        const [{ upload_url: url }, formData] = await Promise.all([
            getServer(copyParams$1(params, serverParams)),
            this.buildPayload({
                field,
                // @ts-ignore
                values: source.values,
                maxFiles,
                attachmentType
            })
        ]);
        const uploaded = await this.upload(url, {
            formData,
            forceBuffer,
            // @ts-ignore
            timeout: source.timeout
        });
        if (typeof uploaded !== 'object') {
            const response = await saveFiles(uploaded);
            return response;
        }
        const response = await saveFiles({
            ...copyParams$1(params, saveParams),
            ...uploaded
        });
        return response;
    }
    /**
     * Building form data
     */
    // eslint-disable-next-line class-methods-use-this
    async buildPayload({ field, values, maxFiles, attachmentType }) {
        const boundary = randomBytes(32).toString('hex');
        const formData = new MultipartStream(boundary);
        const isMultipart = maxFiles > 1;
        const tasks = values
            .map((value) => (typeof value === 'object' && value.constructor === Object
            ? value
            : { value }))
            // @ts-ignore
            .map(async ({ value, filename, contentType = null
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
         }, i) => {
            if (typeof value === 'string') {
                if (isURL.test(value)) {
                    const response = await fetch(value);
                    // eslint-disable-next-line no-param-reassign
                    value = response.body;
                }
                else {
                    // eslint-disable-next-line no-param-reassign
                    value = createReadStream(value);
                }
            }
            if (!filename) {
                // @ts-ignore
                // eslint-disable-next-line no-param-reassign
                filename = `file${i}.${DefaultExtension[attachmentType] || 'dat'}`;
            }
            if (isStream(value) || Buffer.isBuffer(value)) {
                const name = isMultipart
                    ? field + (i + 1)
                    : field;
                const headers = {
                    'Content-Type': contentType === null
                        // @ts-ignore
                        ? DefaultContentType[attachmentType]
                        : contentType
                };
                return formData.append(name, value, { filename, headers });
            }
            throw new UploadError({
                message: 'Unsupported source type',
                code: UNSUPPORTED_SOURCE_TYPE
            });
        });
        await Promise.all(tasks);
        return formData;
    }
    /**
     * Upload form data
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async upload(url, { formData, timeout, forceBuffer }) {
        const { agent, uploadTimeout } = this.vk.options;
        const body = forceBuffer
            ? await streamToBuffer(formData)
            : formData;
        const response = await fetch(url, {
            agent,
            compress: false,
            method: 'POST',
            timeout: timeout || uploadTimeout,
            headers: {
                Connection: 'keep-alive',
                'Content-Type': `multipart/form-data; boundary=${formData.boundary}`
            },
            body
        });
        if (!response.ok) {
            throw new Error(response.statusText);
        }
        const result = await response.json();
        return result.response !== undefined
            ? result.response
            : result;
    }
    /**
     * Custom inspect object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [inspect.custom](depth, options) {
        return `${options.stylize(this.constructor.name, 'special')} {}`;
    }
}

const unespaceOffset = /"offset":"(\w+)"/g;
var getExecuteCode = ({ method, params, parallelCount }) => {
    const methodCode = getExecuteMethod(method, {
        ...params,
        offset: 'offset'
    });
    const code = `
		var total = parseInt(Args.total);
		var offset = parseInt(Args.offset);
		var received = parseInt(Args.received);

		var proceed = total == 0 || received < total;

		var i = 0, items = [], profiles = [], groups = [], result, length;

		while (i < ${parallelCount} && proceed) {
			result = ${methodCode};
			length = result.items.length;

			if (total == 0 || total > result.count) {
				total = result.count;
			}

			items = items + result.items;
			if (result.profiles)
				profiles = profiles + result.profiles;
			if (result.groups)
				groups = groups + result.groups;

			offset = offset + length;
			received = received + length;

			proceed = received < total;
			i = i + 1;
		}

		return {
			total: total,
			items: items.splice(0, total),
			profiles: profiles.splice(0, total),
			groups: groups.splice(0, total)
		};
	`;
    return code.replace(unespaceOffset, '"offset":$1');
};

const debug$1 = createDebug('vk-io:collect:stream');
const { APP_TOKEN_NOT_VALID, RESPONSE_SIZE_TOO_BIG } = APIErrorCode;
const { EXECUTE_ERROR } = CollectErrorCode;
class CollectStream extends Readable {
    /**
     * Constructor
     */
    constructor(vk, { options, method, limit, max }) {
        super({
            objectMode: true
        });
        this.vk = vk;
        const { parallelCount = 25, offset = 0, count, ...params } = options;
        this.method = method;
        this.params = {
            ...params,
            count: limit
        };
        if (parallelCount < 1 || parallelCount > 25) {
            throw new RangeError('The number of parallel calls can be between 1 and 25');
        }
        this.parallelCount = parallelCount;
        const hasMax = max !== undefined;
        const hasCount = count !== undefined;
        // @ts-ignore
        if ((hasCount && hasMax && count > max) || (hasMax && !hasCount)) {
            this.total = max;
        }
        else {
            this.total = count;
        }
        this.offset = offset;
        this.skipOffset = offset;
        this.received = 0;
        this.attempts = 0;
        this.promise = null;
        this.supportExecute = true;
        this.code = getExecuteCode({
            params: this.params,
            parallelCount,
            method
        });
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Promise based
     */
    then(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    thenFn, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    catchFn) {
        if (this.promise === null) {
            const collectItems = [];
            const collectProfiles = [];
            const collectGroups = [];
            this.promise = new Promise((resolve, reject) => {
                this
                    .on('error', reject)
                    .on('end', () => resolve({
                    items: collectItems,
                    profiles: collectProfiles,
                    groups: collectGroups
                }))
                    .on('data', ({ items, profiles, groups }) => {
                    collectItems.push(...items);
                    collectProfiles.push(...profiles);
                    collectGroups.push(...groups);
                });
            });
        }
        return Promise.resolve(this.promise).then(thenFn, catchFn);
    }
    /**
     * Fetch data
     */
    // eslint-disable-next-line no-underscore-dangle
    async _read() {
        const isNotFirst = this.total !== undefined && this.received !== 0;
        if (isNotFirst && (this.total - this.skipOffset) <= this.received) {
            this.push(null);
            return;
        }
        let items;
        let profiles;
        let groups;
        if (!this.supportExecute || this.parallelCount === 1) {
            const request = new APIRequest({
                method: this.method,
                params: {
                    ...this.params,
                    offset: this.offset
                }
            });
            let result;
            try {
                result = await this.vk.api.callWithRequest(request);
            }
            catch (error) {
                const { collectAttempts } = this.vk.options;
                if (this.attempts >= collectAttempts) {
                    this.emit('error', error);
                    return;
                }
                this.attempts += 1;
                // eslint-disable-next-line no-underscore-dangle
                this._read();
                return;
            }
            const { count } = result;
            if (this.total === undefined || this.total > count) {
                this.total = count;
            }
            items = result.items;
            profiles = result.profiles;
            groups = result.groups;
        }
        else {
            let result;
            try {
                result = await this.vk.api.execute({
                    code: this.code,
                    total: this.total,
                    offset: this.offset,
                    received: this.received
                });
            }
            catch (error) {
                if (error.code === APP_TOKEN_NOT_VALID) {
                    this.supportExecute = false;
                    debug$1('execute not supported in token');
                    // eslint-disable-next-line no-underscore-dangle
                    this._read();
                    return;
                }
                if (error.code === RESPONSE_SIZE_TOO_BIG) {
                    this.parallelCount -= 1;
                    this.code = getExecuteCode({
                        parallelCount: this.parallelCount,
                        params: this.params,
                        method: this.method
                    });
                    // eslint-disable-next-line no-underscore-dangle
                    this._read();
                    return;
                }
                const { collectAttempts } = this.vk.options;
                if (this.attempts >= collectAttempts) {
                    this.emit('error', error);
                    return;
                }
                this.attempts += 1;
                // eslint-disable-next-line no-underscore-dangle
                this._read();
                return;
            }
            const { response, errors } = result;
            if (errors.length > 0) {
                this.emit('error', new CollectError({
                    message: 'Execute error',
                    code: EXECUTE_ERROR,
                    errors
                }));
                return;
            }
            this.total = response.total;
            items = response.items;
            profiles = response.profiles;
            groups = response.groups;
        }
        const { length } = items;
        if (length === 0) {
            this.push(null);
            return;
        }
        this.offset += length;
        this.received += length;
        const { total, received } = this;
        let percent = Math.round((received / total) * 100);
        if (Number.isNaN(percent)) {
            percent = 100;
        }
        this.push({
            received,
            percent,
            total,
            items,
            profiles,
            groups
        });
    }
    /**
     * Custom inspect object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [inspect.custom](depth, options) {
        const { total, offset, received } = this;
        const payload = { total, offset, received };
        return `${options.stylize(this.constructor.name, 'special')} ${inspect(payload, options)}`;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    on(event, listener) {
        return super.on(event, listener);
    }
    [Symbol.asyncIterator]() {
        return this[Symbol.asyncIterator]();
    }
}

/**
 * List limits VK
 * Last updated 09.10.2017
 */
var LIMITS_METHODS = [
    /**
     * Account
     */
    ['account.getActiveOffers', 100],
    ['account.getBanned', 200],
    /**
     * Ads
     */
    ['ads.getAds', 100, 2000],
    ['ads.getAdsLayout', 100, 2000],
    ['ads.getAdsTargeting', 100, 2000],
    /**
     * Apps
     */
    ['apps.getCatalog', 100],
    ['apps.getFriendsList', 5000],
    /**
     * Audio
     */
    ['audio.get', 6000],
    ['audio.search', 300, 1000],
    ['audio.getAlbums', 100],
    ['audio.getRecommendations', 1000],
    ['audio.getPopular', 1000],
    /**
     * Board
     */
    ['board.getComments', 100],
    ['board.getTopics', 100],
    /**
     * Database
     */
    ['database.getChairs', 10000],
    ['database.getCities', 1000],
    ['database.getCountries', 1000],
    ['database.getFaculties', 10000],
    ['database.getRegions', 1000],
    ['database.getSchools', 10000],
    ['database.getUniversities', 10000],
    /**
     * Docs
     */
    ['docs.get', 2000, 2000],
    ['docs.search', 1000, 1000],
    /**
     * Fave
     */
    ['fave.getPosts', 100],
    ['fave.getLinks', 100],
    ['fave.getMarketItems', 100],
    ['fave.getPhotos', 100],
    ['fave.getUsers', 100],
    ['fave.getVideos', 100],
    /**
     * Friends
     */
    ['friends.get', 1000],
    ['friends.getMutual', 1000],
    ['friends.getMutual', 1000],
    ['friends.getOnline', 1000],
    ['friends.getRecent', 1000],
    ['friends.getRequests', 1000],
    ['friends.getSuggestions', 500],
    ['friends.search', 1000],
    /**
     * Gifts
     */
    ['gifts.get', 100],
    /**
     * Groups
     */
    ['groups.get', 1000],
    ['groups.getBanned', 200],
    ['groups.getInvitedUsers', 100],
    ['groups.getInvites', 100],
    ['groups.getMembers', 1000],
    ['groups.getRequests', 200],
    /**
     * Leads
     */
    ['leads.getUsers', 1000],
    /**
     * Likes
     */
    ['likes.getList', 100],
    /**
     * Market
     */
    ['market.get', 200],
    ['market.getAlbums', 100],
    ['market.getCategories', 1000],
    ['market.getComments', 100],
    ['market.search', 200],
    /**
     * messages
     */
    ['messages.get', 200],
    ['messages.getHistory', 200],
    ['messages.search', 100],
    ['messages.getConversations', 200],
    /**
     * Notes
     */
    ['notes.get', 100],
    ['notes.getComments', 100],
    /**
     * Orders
     */
    ['orders.get', 1000],
    /**
     * Photos
     */
    ['photos.get', 1000],
    ['photos.getAlbums', 100],
    ['photos.getAll', 200],
    ['photos.getAllComments', 100],
    ['photos.getComments', 100],
    ['photos.getNewTags', 100],
    ['photos.getUserPhotos', 1000],
    ['photos.search', 1000],
    /**
     * Places
     */
    ['places.getCheckins', 100],
    ['places.search', 1000],
    /**
     * Polls
     */
    ['polls.getVoters', 100],
    /**
     * Storage
     */
    ['storage.getKeys', 1000],
    /**
     * Users
     */
    ['users.getFollowers', 1000],
    ['users.getSubscriptions', 200],
    ['users.search', 1000, 1000],
    /**
     * Utils
     */
    ['utils.getLastShortenedLinks', 50],
    /**
     * Video
     */
    ['video.get', 200],
    ['video.getAlbums', 100],
    ['video.getComments', 100],
    ['video.search', 1000, 1000],
    /**
     * Wall
     */
    ['wall.get', 100],
    ['wall.getComments', 100],
    ['wall.getReposts', 1000],
    ['wall.search', 100],
    /**
     * Widgets
     */
    ['widgets.getComments', 200],
    ['widgets.getPages', 200]
];

class Chain {
    /**
     * Constructor
     */
    constructor(vk) {
        this.started = false;
        this.queue = [];
        this.vk = vk;
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Adds method to queue
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    append(method, params) {
        if (this.started) {
            return Promise.reject(new VKError({
                message: 'Chain already started',
                code: 'ALREADY_STARTED'
            }));
        }
        const request = new APIRequest({
            method,
            params
        });
        this.queue.push(request);
        return request.promise;
    }
    /**
     * Promise based
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    then(thenFn, catchFn) {
        // @ts-ignore
        return Promise.resolve(this.run()).then(thenFn, catchFn);
    }
    /**
     * Starts the chain
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async run() {
        if (this.started) {
            throw new VKError({
                message: 'Chain already started',
                code: 'ALREADY_STARTED'
            });
        }
        this.started = true;
        const { queue } = this;
        let out = {
            response: [],
            errors: []
        };
        if (queue.length === 0) {
            return out;
        }
        while (queue.length > 0) {
            const tasks = queue.splice(0, 25);
            const code = getChainReturn(tasks.map(String));
            try {
                const response = await this.vk.api.execute({ code });
                resolveExecuteTask(tasks, response);
                out = {
                    response: [...out.response, ...response.response],
                    errors: [...out.errors, ...response.errors]
                };
            }
            catch (error) {
                for (const task of tasks) {
                    task.reject(error);
                }
                throw error;
            }
        }
        return out;
    }
    /**
     * Custom inspect object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [inspect.custom](depth, options) {
        const { started, queue } = this;
        const payload = { started, queue };
        return `${options.stylize(this.constructor.name, 'special')} ${inspect(payload, options)}`;
    }
}

class Collect {
    /**
     * constructor
     */
    constructor(vk) {
        this.vk = vk;
        for (const [method, limit, max] of LIMITS_METHODS) {
            const [group, name] = method.split('.');
            if (!(group in this)) {
                // @ts-ignore
                this[group] = {};
            }
            // @ts-ignore
            this[group][name] = (options = {}) => (new CollectStream(this.vk, {
                options,
                method,
                limit,
                max
            }));
        }
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Returns new Chain instance
     */
    chain() {
        return new Chain(this.vk);
    }
    /**
     * Call multiple executors
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async executes(method, queue) {
        const queueMethods = queue.map(params => (getExecuteMethod(method, params)));
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const promises = [];
        while (queueMethods.length !== 0) {
            const code = getChainReturn(queueMethods.splice(0, 25));
            promises.push(this.vk.api.execute({ code }));
        }
        let out = {
            response: [],
            errors: []
        };
        for (const { response, errors } of await Promise.all(promises)) {
            out = {
                response: [...out.response, ...response],
                errors: [...out.errors, ...errors]
            };
        }
        return out;
    }
    /**
     * Custom inspect object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [inspect.custom](depth, options) {
        return `${options.stylize(this.constructor.name, 'special')} {}`;
    }
}

class Context {
    /**
     * Constructor
     */
    constructor(options) {
        this.vk = options.vk;
        this.type = options.type;
        this.subTypes = options.subTypes;
        this.payload = options.payload;
        // @ts-ignore
        this.state = options.state || {};
        this.$groupId = options.groupId;
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Checks whether the context of some of these types
     */
    is(rawTypes) {
        const types = !Array.isArray(rawTypes)
            ? [rawTypes]
            : rawTypes;
        return [this.type, ...this.subTypes].some((type) => (types.includes(type)));
    }
    /**
     * Returns data for JSON
     */
    toJSON() {
        return {
            ...this[inspectCustomData](),
            type: this.type,
            subTypes: this.subTypes,
            state: this.state
        };
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { vk, ...payload } = this;
        return payload;
    }
    /**
     * Custom inspect object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [inspect.custom](depth, options) {
        const payload = inspect(this.toJSON(), {
            ...options,
            compact: false
        });
        return `${options.stylize(this.constructor.name, 'special')} ${payload}`;
    }
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
class VoteContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'vote',
            subTypes: [
                'pull_vote'
            ]
        });
    }
    /**
     * Returns the identifier poll
     */
    get id() {
        return this.payload.poll_id;
    }
    /**
     * Returns the identifier user
     */
    get userId() {
        return this.payload.user_id;
    }
    /**
     * Returns the identifier owner
     */
    get ownerId() {
        return this.payload.owner_id;
    }
    /**
     * Returns the identifier option
     */
    get optionId() {
        return this.payload.option_id;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'id',
            'userId',
            'ownerId',
            'optionId'
        ]);
    }
}

const transformPolling = ({ 1: fromId, 2: toId }, updateType) => ({
    from_id: fromId,
    to_id: updateType === 62
        ? toId + CHAT_PEER
        : fromId,
    state: 'typing'
});
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class TypingContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'typing',
            subTypes: [
                `typing_${getPeerType(options.payload.from_id)}`
            ],
            payload: options.source === UpdateSource.POLLING
                // @ts-ignore
                ? transformPolling(options.payload, options.updateType)
                : options.payload
        });
    }
    /**
     * Checks is typing
     */
    get isTyping() {
        return this.payload.state === 'typing';
    }
    /**
     * Checks is record audio message
     */
    get isAudioMessage() {
        return this.payload.state === 'audiomessage';
    }
    /**
     * Checks that the message is typed in the dm
     */
    get isUser() {
        return this.subTypes.includes('typing_user');
    }
    /**
     * Checks that the message is typed in the chat
     */
    get isGroup() {
        return this.subTypes.includes('typing_group');
    }
    /**
     * Checks that the message is typed in the chat
     */
    get isChat() {
        return this.chatId !== null;
    }
    /**
     * Returns the identifier sender
     */
    get fromId() {
        return this.payload.from_id;
    }
    /**
     * Returns the identifier destination
     */
    get toId() {
        return this.payload.to_id;
    }
    /**
     * @deprecated
     */
    get peerId() {
        showDeprecatedMessage('TypingContext, use toId instead of peerId');
        return this.toId;
    }
    /**
     * @deprecated
     */
    get userId() {
        showDeprecatedMessage('TypingContext, use fromId instead of userId');
        return this.fromId;
    }
    /**
     * Returns the identifier chat
     */
    get chatId() {
        const chatId = this.toId - CHAT_PEER;
        return chatId > 0
            ? chatId
            : null;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'fromId',
            'toId',
            'chatId',
            'isUser',
            'isGroup',
            'isChat',
            'isTyping',
            'isAudioMessage'
        ]);
    }
}

const kAttachments$1 = Symbol('attachments');
class MessageReply {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        // @ts-ignore
        this.vk = vk;
        this.payload = payload;
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Checks if there is text
     */
    get hasText() {
        return this.text !== null;
    }
    /**
     * Returns the identifier message
     */
    get id() {
        return this.payload.id;
    }
    /**
     * Returns the conversation message id
     */
    get conversationMessageId() {
        return this.payload.conversation_message_id || null;
    }
    /**
     * Returns the destination identifier
     */
    get peerId() {
        return this.payload.peer_id;
    }
    /**
     * Returns the date when this message was created
     */
    get createdAt() {
        return this.payload.date;
    }
    /**
     * Returns the date when this message was updated
     */
    get updatedAt() {
        return this.payload.update_time;
    }
    /**
     * Returns the message text
     */
    get senderId() {
        return this.payload.from_id;
    }
    /**
     * Returns the message text
     */
    get text() {
        return this.payload.text || null;
    }
    /**
     * Returns the attachments
     */
    get attachments() {
        if (!this[kAttachments$1]) {
            this[kAttachments$1] = transformAttachments(this.payload.attachments, this.vk);
        }
        return this[kAttachments$1];
    }
    /**
     * Returns data for JSON
     */
    toJSON() {
        return copyParams(this, [
            'id',
            'conversationMessageId',
            'peerId',
            'senderId',
            'createdAt',
            'updatedAt',
            'text',
            'attachments'
        ]);
    }
    /**
     * Custom inspect object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [inspect.custom](depth, options) {
        const payload = copyParams(this, [
            'id',
            'conversationMessageId',
            'peerId',
            'senderId',
            'createdAt',
            'updatedAt',
            'text',
            'attachments'
        ]);
        return `${options.stylize(this.constructor.name, 'special')} ${inspect(payload, { ...options, compact: false })}`;
    }
}
applyMixins(MessageReply, [Attachmentable]);

const kForwards = Symbol('forwards');
const kAttachments$2 = Symbol('attachments');
class MessageForward {
    /**
     * Constructor
     */
    constructor(options) {
        this.vk = options.vk;
        this.payload = options.payload;
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Checks if there is text
     */
    get hasText() {
        return this.text !== null;
    }
    /**
     * Returns the date when this message was created
     */
    get createdAt() {
        return this.payload.date;
    }
    /**
     * Returns the date when this message was updated
     */
    get updatedAt() {
        return this.payload.update_time;
    }
    /**
     * Returns the message text
     */
    get senderId() {
        return this.payload.from_id;
    }
    /**
     * Returns the message text
     */
    get text() {
        return this.payload.text || null;
    }
    /**
     * Returns the forwards
     */
    get forwards() {
        if (!this[kForwards]) {
            this[kForwards] = this.payload.fwd_messages
                ? this.payload.fwd_messages.map(forward => (new MessageForward({
                    vk: this.vk,
                    payload: forward
                })))
                : [];
        }
        return this[kForwards];
    }
    /**
     * Returns the attachments
     */
    get attachments() {
        if (!this[kAttachments$2]) {
            this[kAttachments$2] = transformAttachments(this.payload.attachments, this.vk);
        }
        return this[kAttachments$2];
    }
    /**
     * Returns data for JSON
     */
    toJSON() {
        return copyParams(this, [
            'senderId',
            'createdAt',
            'updatedAt',
            'text',
            'attachments',
            'forwards'
        ]);
    }
    /**
     * Custom inspect object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [inspect.custom](depth, options) {
        const payload = copyParams(this, [
            'senderId',
            'createdAt',
            'updatedAt',
            'text',
            'attachments',
            'forwards'
        ]);
        return `${options.stylize(this.constructor.name, 'special')} ${inspect(payload, { ...options, compact: false })}`;
    }
}
applyMixins(MessageForward, [Attachmentable]);

/* eslint-disable @typescript-eslint/camelcase */
/**
 * Special attachments in one message
 */
const specialAttachments = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    sticker: (raw) => ({
        type: 'sticker',
        sticker: {
            sticker_id: Number(raw.attach1),
            product_id: Number(raw.attach1_product_id)
        }
    }),
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    money_transfer: (raw) => ({
        type: 'money_transfer',
        money_transfer: {
            data: raw.attach1,
            amount: Number(raw.attach1_amount),
            currency: Number(raw.attach1_currency)
        }
    }),
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    gift: (raw) => ({
        type: 'gift',
        gift: {
            id: Number(raw.attach1)
        }
    })
};
/**
 * Transform message to Object
 */
function transformMessage({ 1: id, 2: flags, 3: peer, 4: date, 5: text, 6: extra, 7: attachments, 8: random_id
// eslint-disable-next-line @typescript-eslint/no-explicit-any
 }) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const message = {
        id,
        date,
        text,
        random_id,
        geo: attachments.geo !== undefined
            ? {}
            : null,
        payload: extra.payload
            ? extra.payload
            : null
    };
    message.peer_id = peer;
    if (extra.from !== undefined) {
        message.from_id = Number(extra.from);
    }
    else {
        message.from_id = peer;
    }
    if (peer < 0 && message.peer_id !== message.from_id) {
        // eslint-disable-next-line no-bitwise
        message.out = Number((flags & 2) === 0);
        // eslint-disable-next-line no-bitwise
        message.important = (flags & 1) !== 0;
    }
    else {
        // eslint-disable-next-line no-bitwise
        message.out = Number((flags & 2) !== 0);
        // eslint-disable-next-line no-bitwise
        message.important = (flags & 8) !== 0;
    }
    if (extra.source_act !== undefined) {
        message.action = {
            type: extra.source_act,
            text: extra.source_text,
            member_id: extra.source_mid
        };
    }
    if (attachments.attach1_type in specialAttachments) {
        message.attachments = [
            specialAttachments[attachments.attach1_type](attachments)
        ];
    }
    else {
        const messageAttachments = [];
        for (let i = 1, key = 'attach1'; attachments[key] !== undefined; i += 1, key = `attach${i}`) {
            const type = attachments[`${key}_type`];
            if (type === 'link') {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const attachment = {
                    type: 'link',
                    link: {
                        url: attachments[`${key}_url`],
                        title: attachments[`${key}_title`],
                        description: attachments[`${key}_desc`]
                    }
                };
                const photoKey = `${key}_photo`;
                if (attachments[photoKey]) {
                    const [owner, attachmentId] = attachments[photoKey].split('_');
                    attachment.link.photo = {
                        id: Number(attachmentId),
                        owner_id: Number(owner)
                    };
                }
                messageAttachments.push(attachment);
                continue;
            }
            const [owner, attachmentId] = attachments[key].split('_');
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const attachment = {
                type,
                [type]: {
                    id: Number(attachmentId),
                    owner_id: Number(owner)
                }
            };
            const kindKey = `${key}_kind`;
            if (type === 'doc' && attachments[kindKey] !== undefined) {
                attachment[type].kind = attachments[kindKey];
            }
            messageAttachments.push(attachment);
        }
        message.attachments = messageAttachments;
    }
    let { fwd } = attachments;
    // Now long poll receive such forward messages 0_0,0_0
    // Only for checking the presence of a sent message
    if (fwd !== undefined) {
        const indexColon = fwd.indexOf(':');
        if (indexColon !== -1) {
            fwd = fwd.substring(0, indexColon);
        }
        message.fwd_messages = fwd
            .split(',')
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            .map((attachment) => {
            const [owner] = attachment.split('_');
            return {
                date: 0,
                from_id: Number(owner),
                text: '',
                fwd_messages: [],
                attachments: [],
                update_time: 0
            };
        });
    }
    return message;
}

const getForwards = (rootForwards) => {
    const forwards = [];
    for (const forward of rootForwards) {
        forwards.push(forward, ...getForwards(forward.forwards));
    }
    return forwards;
};
const kFlatten = Symbol('flatten');
class MessageForwardsCollection extends Array {
    /**
     * Returns a flat copy of forwards
     */
    get flatten() {
        if (!this[kFlatten]) {
            this[kFlatten] = getForwards(this);
        }
        return this[kFlatten];
    }
}
applyMixins(MessageForwardsCollection, [
    class CustomAttachmentable {
        hasAttachments(type = null) {
            return this.flatten.some(forward => (forward.hasAttachments(type)));
        }
        getAttachments(type = null) {
            const attachments = this.flatten.map(forward => (
            // @ts-ignore
            forward.getAttachments(type)));
            // @ts-ignore
            return [].concat(...attachments);
        }
    }
]);

/* eslint-disable max-classes-per-file */
const subTypesEnum = {
    4: 'new_message',
    5: 'edit_message',
    message_new: 'new_message',
    message_edit: 'edit_message',
    message_reply: 'reply_message'
};
const kForwards$1 = Symbol('forwards');
const kReplyMessage = Symbol('replyMessage');
const kAttachments$3 = Symbol('attachments');
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class MessageContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'message',
            subTypes: []
        });
        let { payload } = options;
        if (options.source === UpdateSource.POLLING) {
            // eslint-disable-next-line no-param-reassign
            // @ts-ignore
            payload = transformMessage(payload);
            this.$filled = false;
        }
        else {
            this.$filled = true;
        }
        this.applyPayload(payload);
        this.subTypes = [
            this.eventType || subTypesEnum[options.updateType]
        ];
    }
    /**
     * Load message payload
     */
    async loadMessagePayload() {
        if (this.$filled) {
            return;
        }
        const { items } = this.id !== 0
            ? await this.vk.api.messages.getById({
                message_ids: this.id
            })
            : await this.vk.api.messages.getByConversationMessageId({
                peer_id: this.peerId,
                conversation_message_ids: this.conversationMessageId
            });
        const [message] = items;
        this[kForwards$1] = null;
        this[kAttachments$3] = null;
        this[kReplyMessage] = null;
        // @ts-ignore
        this.applyPayload(message);
        this.$filled = true;
    }
    /**
     * Checks if there is text
     */
    get hasText() {
        return Boolean(this.text);
    }
    /**
     * Checks for reply message
     */
    get hasReplyMessage() {
        return this.replyMessage !== null;
    }
    /**
     * Checks for forwarded messages
     */
    get hasForwards() {
        return this.forwards.length > 0;
    }
    /**
     * Checks for hast message payload
     */
    get hasMessagePayload() {
        return Boolean(this.message.payload);
    }
    /**
     * Checks if there is text
     */
    get hasGeo() {
        return Boolean(this.message.geo);
    }
    /**
     * Checks is a chat
     */
    get isChat() {
        return this.peerType === MessageSource.CHAT;
    }
    /**
     * Check is a user
     */
    get isUser() {
        return this.senderType === MessageSource.USER;
    }
    /**
     * Checks is a group
     */
    get isGroup() {
        return this.senderType === MessageSource.GROUP;
    }
    /**
     * Checks is from the user
     */
    get isFromUser() {
        return this.peerType === MessageSource.USER;
    }
    /**
     * Checks is from the group
     */
    get isFromGroup() {
        return this.peerType === MessageSource.GROUP;
    }
    /**
     * Checks a message has arrived in direct messages
     */
    get isDM() {
        return this.isFromUser || this.isFromGroup;
    }
    /**
     * Check is special event
     */
    get isEvent() {
        return this.eventType !== null;
    }
    /**
     * Checks whether the message is outbox
     */
    get isOutbox() {
        return Boolean(this.message.out);
    }
    /**
     * Checks whether the message is inbox
     */
    get isInbox() {
        return !this.isOutbox;
    }
    /**
     * Checks that the message is important
     */
    get isImportant() {
        return this.message.important;
    }
    /**
     * Returns the identifier message
     */
    get id() {
        return this.message.id;
    }
    /**
     * Returns the conversation message id
     */
    get conversationMessageId() {
        return this.message.conversation_message_id || null;
    }
    /**
     * Returns the destination identifier
     */
    get peerId() {
        return this.message.peer_id;
    }
    /**
     * Returns the peer type
     */
    get peerType() {
        return getPeerType(this.message.peer_id);
    }
    /**
     * Returns the sender identifier
     */
    get senderId() {
        return this.message.from_id;
    }
    /**
     * Returns the sender type
     */
    get senderType() {
        return getPeerType(this.message.from_id);
    }
    /**
     * Returns the identifier chat
     */
    get chatId() {
        if (!this.isChat) {
            return null;
        }
        return this.peerId - CHAT_PEER;
    }
    /**
     * Returns the referral value
     */
    get referralValue() {
        return this.message.ref;
    }
    /**
     * Returns the referral source
     */
    get referralSource() {
        return this.message.ref_source;
    }
    /**
     * Returns the date when this message was created
     */
    get createdAt() {
        return this.message.date;
    }
    /**
     * Returns geo
     */
    get geo() {
        if (!this.hasGeo) {
            return null;
        }
        if (!this.$filled) {
            throw new VKError({
                message: 'The message payload is not fully loaded',
                code: 'PAYLOAD_IS_NOT_FULL'
            });
        }
        return this.message.geo;
    }
    /**
     * Returns the event name
     */
    get eventType() {
        return (this.message.action
            && this.message.action.type) || null;
    }
    /**
     * Returns the event member id
     */
    get eventMemberId() {
        return (this.message.action
            && this.message.action.member_id) || null;
    }
    /**
     * Returns the event name
     */
    get eventText() {
        return (this.message.action
            && this.message.action.text) || null;
    }
    /**
     * Returns the event email
     */
    get eventEmail() {
        return (this.message.action
            && this.message.action.email) || null;
    }
    /**
     * Returns the message payload
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    get messagePayload() {
        const { payload = null } = this.message;
        if (payload === null) {
            return null;
        }
        return JSON.parse(payload);
    }
    /**
     * Returns the forwards
     */
    get forwards() {
        if (!this[kForwards$1]) {
            this[kForwards$1] = this.message.fwd_messages
                ? new MessageForwardsCollection(...this.message.fwd_messages.map(forward => (new MessageForward({
                    vk: this.vk,
                    // @ts-ignore
                    payload: forward
                }))))
                : new MessageForwardsCollection();
        }
        return this[kForwards$1];
    }
    /**
     * Returns the reply message
     */
    get replyMessage() {
        if (!this[kReplyMessage]) {
            this[kReplyMessage] = this.message.reply_message
                ? new MessageReply(this.message.reply_message, this.vk)
                : null;
        }
        return this[kReplyMessage];
    }
    /**
     * Returns the attachments
     */
    get attachments() {
        if (!this[kAttachments$3]) {
            this[kAttachments$3] = transformAttachments(this.message.attachments, this.vk);
        }
        return this[kAttachments$3];
    }
    /**
     * Returns the capabilities of the client the user is using.
     */
    get clientInfo() {
        return this.payload.client_info;
    }
    /**
     * Gets a link to invite the user to a conversation
     */
    getInviteLink(params = {}) {
        return this.vk.api.messages.getInviteLink({
            ...params,
            peer_id: this.peerId
        });
    }
    /**
     * Edits a message
     */
    editMessage(params) {
        return this.vk.api.messages.edit({
            attachment: String(this.attachments.filter(attachment => (attachment.canBeAttached))),
            message: this.text,
            keep_forward_messages: 1,
            keep_snippets: 1,
            ...params,
            peer_id: this.peerId,
            message_id: this.id
        });
    }
    /**
     * Edits a message text
     */
    async editMessageText(message) {
        const response = await this.editMessage({ message });
        this.text = message;
        return response;
    }
    /**
     * Sends a message to the current dialog
     */
    send(text, params) {
        return this.vk.api.messages.send({
            peer_id: this.peerId,
            ...(typeof text !== 'object'
                ? {
                    message: text,
                    ...params
                }
                : text)
        });
    }
    /**
     * Responds to the current message
     */
    reply(text, params) {
        return this.send({
            reply_to: this.id,
            ...(typeof text !== 'object'
                ? {
                    message: text,
                    ...params
                }
                : text)
        });
    }
    /**
     * Sends a sticker to the current dialog
     */
    sendSticker(id) {
        return this.send({
            sticker_id: id
        });
    }
    /**
     * Sends a photos to the current dialog
     */
    async sendPhotos(rawSources, params = {}) {
        const sources = !Array.isArray(rawSources)
            ? [rawSources]
            : rawSources;
        const attachment = await Promise.all(sources.map(source => (this.vk.upload.messagePhoto({
            source,
            peer_id: this.peerId
        }))));
        const response = await this.send({
            ...params,
            attachment
        });
        return response;
    }
    /**
     * @deprecated
     */
    async sendPhoto(rawSources, params = {}) {
        showDeprecatedMessage('MessageContext, use sendPhotos instead of sendPhoto');
        return this.sendPhotos(rawSources, params);
    }
    /**
     * Sends a documents to the current dialog
     */
    async sendDocuments(rawSources, params = {}) {
        const sources = !Array.isArray(rawSources)
            ? [rawSources]
            : rawSources;
        const attachment = await Promise.all(sources.map(source => (this.vk.upload.messageDocument({
            source,
            peer_id: this.peerId
        }))));
        const response = await this.send({
            ...params,
            attachment
        });
        return response;
    }
    /**
     * @deprecated
     */
    async sendDocument(rawSources, params = {}) {
        showDeprecatedMessage('MessageContext, use sendDocuments instead of sendDocument');
        return this.sendDocuments(rawSources, params);
    }
    /**
     * Sends a audio message to the current dialog
     */
    async sendAudioMessage(source, params = {}) {
        const attachment = await this.vk.upload.audioMessage({
            source,
            peer_id: this.peerId
        });
        const response = await this.send({
            ...params,
            attachment
        });
        return response;
    }
    /**
     * Changes the status of typing in the dialog
     */
    async setActivity() {
        const isActivited = await this.vk.api.messages.setActivity({
            peer_id: this.peerId,
            type: 'typing'
        });
        return Boolean(isActivited);
    }
    /**
     * Marks messages as important or removes a mark
     */
    async markAsImportant(ids = [this.id], options = { important: Number(!this.isImportant) }) {
        const messageIds = await this.vk.api.messages.markAsImportant({
            ...options,
            message_ids: ids
        });
        if (messageIds.includes(this.id)) {
            this.message.important = Boolean(options.important);
        }
        return messageIds;
    }
    /**
     * Deletes the message
     */
    async deleteMessage(ids = [this.id], options = { spam: 0 }) {
        const messageIds = await this.vk.api.messages.delete({
            ...options,
            message_ids: ids
        });
        return messageIds;
    }
    /**
     * Restores the message
     */
    async restoreMessage() {
        const isRestored = await this.vk.api.messages.restore({
            message_id: this.id
        });
        return Boolean(isRestored);
    }
    /**
     * Rename the chat
     */
    async renameChat(title) {
        this.assertIsChat();
        const isRenamed = await this.vk.api.messages.editChat({
            chat_id: this.chatId,
            title
        });
        return Boolean(isRenamed);
    }
    /**
     * Sets a new image for the chat
     */
    async newChatPhoto(source, params = {}) {
        this.assertIsChat();
        const response = await this.vk.upload.chatPhoto({
            ...params,
            chat_id: this.chatId,
            source
        });
        return response;
    }
    /**
     * Remove the chat photo
     */
    async deleteChatPhoto() {
        this.assertIsChat();
        await this.vk.api.messages.deleteChatPhoto({
            chat_id: this.chatId
        });
        return true;
    }
    /**
     * Invites a new user
     */
    async inviteUser(id = this.eventMemberId) {
        this.assertIsChat();
        const isInvited = await this.vk.api.messages.addChatUser({
            chat_id: this.chatId,
            user_id: id
        });
        return Boolean(isInvited);
    }
    /**
     * Excludes user
     */
    async kickUser(id = this.eventMemberId) {
        this.assertIsChat();
        const isKicked = await this.vk.api.messages.removeChatUser({
            chat_id: this.chatId,
            member_id: id
        });
        return Boolean(isKicked);
    }
    /**
     * Pins a message
     */
    async pinMessage() {
        this.assertIsChat();
        const isPinned = await this.vk.api.messages.pin({
            peer_id: this.peerId,
            message_id: this.id
        });
        return Boolean(isPinned);
    }
    /**
     * Unpins a message
     */
    async unpinMessage() {
        this.assertIsChat();
        const isUnpinned = await this.vk.api.messages.unpin({
            peer_id: this.peerId,
            message_id: this.id
        });
        return Boolean(isUnpinned);
    }
    /**
     * Return alias of payload.message
     */
    get message() {
        return this.payload.message;
    }
    /**
     * Applies the payload
     */
    applyPayload(payload) {
        // Polyfill for all events except new_message
        if (payload.client_info === undefined) {
            // eslint-disable-next-line no-param-reassign
            payload = {
                // @ts-ignore
                message: payload,
                client_info: {
                    button_actions: [
                        'text'
                    ],
                    inline_keyboard: false,
                    keyboard: true,
                    lang_id: 0
                }
            };
        }
        this.payload = payload;
        this.text = payload.message.text
            ? unescapeHTML(payload.message.text)
            : null;
    }
    /**
     * Checks that in a chat
     */
    assertIsChat() {
        if (!this.isChat) {
            throw new VKError({
                message: 'This method is only available in chat',
                code: 'IS_NOT_CHAT'
            });
        }
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        const beforeAttachments = [];
        if (this.isEvent) {
            beforeAttachments.push('eventType', 'eventMemberId', 'eventText', 'eventEmail');
        }
        if (this.hasReplyMessage) {
            beforeAttachments.push('replyMessage');
        }
        const afterAttachments = [];
        if (this.hasMessagePayload) {
            afterAttachments.push('messagePayload');
        }
        afterAttachments.push('isOutbox');
        if (this.referralValue) {
            afterAttachments.push('referralValue', 'referralSource');
        }
        if (this.$match) {
            afterAttachments.push('$match');
        }
        // @ts-ignore
        return copyParams(this, [
            'id',
            'conversationMessageId',
            'peerId',
            'peerType',
            'senderId',
            'senderType',
            'createdAt',
            'text',
            ...beforeAttachments,
            'forwards',
            'attachments',
            ...afterAttachments
        ]);
    }
}
applyMixins(MessageContext, [
    Attachmentable,
    class AllAttachmentable extends Attachmentable {
        hasAllAttachments(type = null) {
            return (this.hasAttachments(type)
                || (this.replyMessage && this.replyMessage.hasAttachments(type))
                || this.forwards.hasAttachments(type));
        }
        getAllAttachments(type) {
            return [
                // @ts-ignore
                ...this.getAttachments(type),
                // @ts-ignore
                ...((this.replyMessage && this.replyMessage.getAttachments(type)) || []),
                // @ts-ignore
                ...this.forwards.getAttachments(type)
            ];
        }
    }
]);

const subTypes = {
    wall_post_new: 'new_wall_post',
    wall_repost: 'new_wall_repost'
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class WallPostContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'wall_post',
            subTypes: [
                subTypes[options.updateType]
            ]
        });
        // @ts-ignore
        this.wall = new WallAttachment(this.payload, this.vk);
    }
    /**
     * Checks is repost
     */
    get isRepost() {
        return this.subTypes.includes('new_wall_repost');
    }
    /**
     * Removes a record from the wall
     */
    deletePost() {
        const { wall } = this;
        return this.vk.api.wall.delete({
            post_id: wall.id,
            owner_id: wall.ownerId
        });
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'wall',
            'isRepost'
        ]);
    }
}

/**
 * Causes of blocking
 */
const reasonNames = new Map([
    [0, 'other'],
    [1, 'spam'],
    [2, 'members_insult'],
    [3, 'obscene_expressions'],
    [4, 'messages_off_topic']
]);
const subTypes$1 = {
    user_block: 'block_group_user',
    user_unblock: 'unblock_group_user'
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class GroupUserContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'group_user',
            subTypes: [
                subTypes$1[options.updateType]
            ]
        });
    }
    /**
     * Checks is join user
     */
    get isBlocked() {
        return this.subTypes.includes('block_group_user');
    }
    /**
     * Checks is leave user
     */
    get isUnblocked() {
        return this.subTypes.includes('unblock_group_user');
    }
    /**
     * Checks that the block has expired
     */
    get isExpired() {
        if (this.isBlocked) {
            return null;
        }
        return Boolean(this.payload.by_end_date);
    }
    /**
     * Returns the identifier admin
     */
    get adminId() {
        return this.payload.admin_id;
    }
    /**
     * Returns the identifier user
     */
    get userId() {
        return this.payload.user_id;
    }
    /**
     * Returns the reason for the ban
     */
    get reasonId() {
        return this.payload.reason || null;
    }
    /**
     * Returns the reason name for the ban
     */
    get reasonName() {
        // @ts-ignore
        return reasonNames.get(this.reasonId);
    }
    /**
     * Returns the unblock date or null if permanent
     */
    get unblockAt() {
        return this.payload.unblock_date || null;
    }
    /**
     * Returns the administrator comment to block
     */
    get comment() {
        return this.payload.comment || null;
    }
    /**
     * Adds a user to the community blacklist
     */
    ban(params) {
        if (this.isBlocked) {
            return Promise.reject(new VKError({
                message: 'User is blocked',
                code: 'ALREADY_BANNED'
            }));
        }
        return this.vk.api.groups.ban({
            ...params,
            group_id: this.$groupId,
            user_id: this.userId
        });
    }
    /**
     * Adds a user to the community blacklist
     */
    unban() {
        if (this.isUnblocked) {
            return Promise.reject(new VKError({
                message: 'User is not blocked',
                code: 'ALREADY_UNBANNED'
            }));
        }
        return this.vk.api.groups.unban({
            group_id: this.$groupId,
            user_id: this.userId
        });
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'adminId',
            'userId',
            'reasonId',
            'reasonName',
            'comment',
            'isExpired',
            'isBlocked',
            'isUnblocked'
        ]);
    }
}

const subTypes$2 = {
    8: 'user_online',
    9: 'user_offline'
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class UserOnlineContext extends Context {
    constructor(options) {
        const [eventId, userId, extra, date] = options.payload;
        super({
            ...options,
            type: 'user_active',
            subTypes: [
                subTypes$2[eventId]
            ],
            payload: {
                user_id: -userId,
                extra,
                date
            }
        });
    }
    /**
     * Checks that the user is online
     */
    get isUserOnline() {
        return this.subTypes.includes('user_online');
    }
    /**
     * Checks that the user is online
     */
    get isUserOffline() {
        return this.subTypes.includes('user_offline');
    }
    /**
     * Checks that the user has logged out of the network himself
     */
    get isSelfExit() {
        return this.isUserOffline && !this.payload.extra;
    }
    /**
     * Checks that the user logged out a timeout
     */
    get isTimeoutExit() {
        return this.isUserOffline && Boolean(this.payload.extra);
    }
    /**
     * Returns the user id
     */
    get userId() {
        return this.payload.user_id || null;
    }
    /**
     * Returns the date when this event was created
     */
    get createdAt() {
        return this.payload.date;
    }
    /**
     * Returns the name of the platform from which the user entered
     */
    get platformName() {
        return platforms.get(this.payload.extra);
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'userId',
            'createdAt',
            'platformName',
            'isSelfExit',
            'isTimeoutExit',
            'isUserOnline',
            'isUserOffline'
        ]);
    }
}

const subTypes$3 = {
    10: 'remove_dialog_flags',
    11: 'update_dialog_flags',
    12: 'set_dialog_flags'
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class DialogFlagsContext extends Context {
    constructor(options) {
        const [eventId, peerId, flags] = options.payload;
        super({
            ...options,
            type: 'dialog_flags',
            subTypes: [
                subTypes$3[eventId]
            ],
            payload: {
                peer_id: peerId,
                flags
            }
        });
    }
    /**
     * Checks that an important dialogue
     */
    get isImportant() {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & 1);
    }
    /**
     * Checks that the unanswered dialog
     */
    get isUnanswered() {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & 2);
    }
    /**
     * Returns the destination identifier
     */
    get peerId() {
        return this.payload.peer_id;
    }
    /**
     * Returns the values of the flags
     */
    get flags() {
        return this.payload.flags;
    }
    /**
     * Marks the conversation as answered or unchecked
     */
    markAsAnsweredConversation(params) {
        return this.vk.api.messages.markAsAnsweredConversation({
            ...params,
            peer_id: this.peerId
        });
    }
    /**
     * Marks the conversation as important or removes the mark
     */
    markAsImportantConversation(params) {
        return this.vk.api.messages.markAsImportantConversation({
            ...params,
            peer_id: this.peerId
        });
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'peerId',
            'flags',
            'isImportant',
            'isUnanswered'
        ]);
    }
}

const subTypes$4 = {
    group_change_photo: 'group_update_photo',
    group_update_officers: 'group_update_officers',
    group_change_settings: 'group_update_settings'
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class GroupUpdateContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'group_update',
            subTypes: [
                subTypes$4[options.updateType]
            ]
        });
        this.attachments = options.updateType === 'group_change_photo'
            // @ts-ignore
            ? [new PhotoAttachment(this.payload.photo, this.vk)]
            : [];
    }
    /**
     * Checks is change photo
     */
    get isChangePhoto() {
        return this.subTypes.includes('group_update_photo');
    }
    /**
     * Checks is change officers
     */
    get isChangeOfficers() {
        return this.subTypes.includes('group_update_officers');
    }
    /**
     * Checks is change settings
     */
    get isChangeSettings() {
        return this.subTypes.includes('group_update_settings');
    }
    /**
     * Returns the identifier admin
     */
    get adminId() {
        return this.payload.admin_id || null;
    }
    /**
     * Returns the identifier user
     */
    get userId() {
        return this.payload.user_id;
    }
    /**
     * Returns the old level permission
     */
    get oldLevel() {
        return this.payload.level_old || null;
    }
    /**
     * Returns the new level permission
     */
    get newLevel() {
        return this.payload.level_new || null;
    }
    /**
     * Returns the changes settings
     */
    get changes() {
        return this.payload.changes || null;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'adminId',
            'userId',
            'oldLevel',
            'newLevel',
            'changes',
            'attachments'
        ]);
    }
}
applyMixins(GroupUpdateContext, [Attachmentable]);

const subTypes$5 = {
    group_leave: 'leave_group_member',
    group_join: 'join_group_member'
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class GroupMemberContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'group_member',
            subTypes: [
                subTypes$5[options.updateType]
            ]
        });
    }
    /**
     * Checks is join user
     */
    get isJoin() {
        return this.subTypes.includes('join_group_member');
    }
    /**
     * Checks is leave user
     */
    get isLeave() {
        return this.subTypes.includes('leave_group_member');
    }
    /**
     * Checks is self leave user
     */
    get isSelfLeave() {
        if (this.isJoin) {
            return null;
        }
        return Boolean(this.payload.self);
    }
    /**
     * Returns the identifier user
     */
    get userId() {
        return this.payload.user_id;
    }
    /**
     * Returns the join type
     */
    get joinType() {
        if (this.isLeave) {
            return null;
        }
        return this.payload.join_type;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'userId',
            'joinType',
            'isJoin',
            'isLeave',
            'isSelfLeave'
        ]);
    }
}

const subTypes$6 = {
    message_allow: 'message_subscribe',
    message_deny: 'message_unsubscribe'
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class MessageAllowContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'message_subscribers',
            subTypes: [
                subTypes$6[options.updateType]
            ]
        });
    }
    /**
     * Checks that the user has subscribed to messages
     */
    get isSubscribed() {
        return this.subTypes.includes('message_subscribe');
    }
    /**
     * Checks that the user has unsubscribed from the messages
     */
    get isUbsubscribed() {
        return this.subTypes.includes('message_unsubscribe');
    }
    /**
     * Returns the identifier user
     */
    get userId() {
        return this.payload.user_id;
    }
    /**
     * Returns the key
     */
    get key() {
        return this.payload.key || null;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'userId',
            'key',
            'isSubscribed',
            'isUbsubscribed'
        ]);
    }
}

const subTypes$7 = {
    6: 'read_inbox_messages',
    7: 'read_outbox_messages'
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class ReadMessagesContext extends Context {
    constructor(options) {
        const [eventId, peerId, id] = options.payload;
        super({
            ...options,
            type: 'read_messages',
            subTypes: [
                subTypes$7[eventId]
            ],
            payload: {
                peer_id: peerId,
                id
            }
        });
    }
    /**
     * Checks that inbox messages are read
     */
    get isInbox() {
        return this.subTypes.includes('read_inbox_messages');
    }
    /**
     * Checks that outbox messages are read
     */
    get isOutbox() {
        return this.subTypes.includes('read_outbox_messages');
    }
    /**
     * Returns the ID before the message read
     */
    get id() {
        return this.payload.id;
    }
    /**
     * Returns the peer ID
     */
    get peerId() {
        return this.payload.peer_id;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'id',
            'peerId',
            'isInbox',
            'isOutbox'
        ]);
    }
}

const subTypes$8 = {
    1: 'update_message_flags',
    2: 'set_message_flags',
    3: 'remove_message_flags'
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class MessageFlagsContext extends Context {
    constructor(options) {
        const [eventId, id, flags, peerId] = options.payload;
        super({
            ...options,
            type: 'message_flags',
            subTypes: [
                subTypes$8[eventId]
            ],
            payload: {
                peer_id: peerId,
                flags,
                id
            }
        });
    }
    /**
     * Verifies that the message is not read
     */
    get isUnread() {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & 1);
    }
    /**
     * Checks that the outgoing message
     */
    get isOutbox() {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & 2);
    }
    /**
     * Verifies that a reply has been created to the message
     */
    get isReplied() {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & 4);
    }
    /**
     * Verifies that the marked message
     */
    get isImportant() {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & 8);
    }
    /**
     * Verifies that the message was sent via chat
     */
    get isChat() {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & 16);
    }
    /**
     * Verifies that the message was sent by a friend
     */
    get isFriends() {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & 32);
    }
    /**
     * Verifies that the message is marked as "Spam"
     */
    get isSpam() {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & 64);
    }
    /**
     * Verifies that the message has been deleted (in the Recycle Bin)
     */
    get isDeleted() {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & 128);
    }
    /**
     * Verifies that the message was verified by the user for spam
     */
    get isFixed() {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & 256);
    }
    /**
     * Verifies that the message contains media content
     */
    get isMedia() {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & 512);
    }
    /**
     * Checks that a welcome message from the community
     */
    get isHidden() {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & 65536);
    }
    /**
     * Message deleted for all recipients
     */
    get isDeletedForAll() {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & 131072);
    }
    /**
     * Returns the message ID
     */
    get id() {
        return this.payload.id;
    }
    /**
     * Returns the destination identifier
     */
    get peerId() {
        return this.payload.peer_id;
    }
    /**
     * Returns the values of the flags
     */
    get flags() {
        return this.payload.flags;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'id',
            'peerId',
            'flags'
        ]);
    }
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
class VKAppPayloadContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'vk_app_event',
            subTypes: ['vk_app_payload']
        });
    }
    /**
     * Returns the identifier of the user whose action the event was sent to in the application
     */
    get userId() {
        return this.payload.user_id;
    }
    /**
     * Returns the identifier of the application from which the event was sent
     */
    get appId() {
        return this.payload.app_id;
    }
    /**
     * Returns the identifier of the community to which the notification was sent
     */
    get groupId() {
        return this.payload.group_id;
    }
    /**
     * Returns the transferred useful data
     */
    get eventPayload() {
        return this.payload.payload;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'userId',
            'appId',
            'groupId',
            'eventPayload'
        ]);
    }
}

/**
 * Find types
 *
 * ```
 * wall_reply_new
 * ```
 */
const findTypes = /([^_]+)_([^_]+)_([^_]+)/;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class CommentActionContext extends Context {
    constructor(options) {
        const { 1: initiator, 3: action } = options.updateType.match(findTypes);
        super({
            ...options,
            type: 'comment',
            subTypes: [
                `${initiator}_comment`,
                `${action}_${initiator}_comment`
            ]
        });
        this.attachments = transformAttachments(this.payload.attachments, this.vk);
    }
    /**
     * Checks is new comment
     */
    get isNew() {
        return this.includesFromSubType('new');
    }
    /**
     * Checks is edit comment
     */
    get isEdit() {
        return this.includesFromSubType('edit');
    }
    /**
     * Checks is delete comment
     */
    get isDelete() {
        return this.includesFromSubType('delete');
    }
    /**
     * Checks is restore comment
     */
    get isRestore() {
        return this.includesFromSubType('restore');
    }
    /**
     * Checks is photo comment
     */
    get isPhotoComment() {
        return this.includesFromSubType('photo');
    }
    /**
     * Checks is wall comment
     */
    get isWallComment() {
        return this.includesFromSubType('wall');
    }
    /**
     * Checks is video comment
     */
    get isVideoComment() {
        return this.includesFromSubType('video');
    }
    /**
     * Checks is board comment
     */
    get isBoardComment() {
        return this.includesFromSubType('board');
    }
    /**
     * Checks is board comment
     */
    get isMarketComment() {
        return this.includesFromSubType('market');
    }
    /**
     * Checks is reply comment
     */
    get isReply() {
        return 'reply_to_comment' in this.payload;
    }
    /**
     * Checks if the user wrote a message
     */
    get isUser() {
        return this.fromId > 0;
    }
    /**
     * Checks if the group wrote a message
     */
    get isGroup() {
        return this.fromId < 0;
    }
    /**
     * Returns the identifier comment
     */
    get id() {
        return this.payload.id;
    }
    /**
     * Returns the identifier reply comment
     */
    get replyId() {
        return this.payload.reply_to_comment || null;
    }
    /**
     * identifier of who wrote the comment
     */
    get fromId() {
        return (this.payload.from_id
            || this.payload.user_id
            || null);
    }
    /**
     * Returns the identifier user
     */
    get userId() {
        showDeprecatedMessage('context.userId deperecated, use context.fromId');
        return this.fromId;
    }
    /**
     * Returns the identifier reply user
     */
    get replyUserId() {
        return this.payload.reply_to_user || null;
    }
    /**
     * Returns the identifier of the user who deleted the comment
     */
    get removerUserId() {
        return this.payload.deleter_id || null;
    }
    /**
     * Returns the identifier of object
     */
    get objectId() {
        const { payload } = this;
        return (payload.photo_id
            || payload.video_id
            || payload.post_id
            || payload.topic_id
            || payload.item_id
            || null);
    }
    /**
     * Returns the identifier of owner
     */
    get ownerId() {
        const { payload } = this;
        return (payload.owner_id
            || payload.photo_owner_id
            || payload.video_owner_id
            || payload.post_owner_id
            || payload.topic_owner_id
            || payload.market_owner_id
            || null);
    }
    /**
     * Returns the date creation action comment
     */
    get createdAt() {
        return this.payload.date || null;
    }
    /**
     * Returns the text comment
     */
    get text() {
        return this.payload.text || null;
    }
    /**
     * Returns the likes
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    get likes() {
        return this.payload.likes || null;
    }
    /**
     * Includes from subtype
     */
    includesFromSubType(type) {
        return this.subTypes[1].includes(type);
    }
    /**
     * Edits a comment
     */
    editComment(options) {
        if (this.isDelete) {
            return Promise.reject(new VKError({
                message: 'Comment is deleted',
                code: 'ALREADY_DELETED'
            }));
        }
        if (this.isBoardComment) {
            // @ts-ignore
            return this.vk.api.board.editComment({
                ...options,
                comment_id: this.id,
                topic_id: this.objectId,
                group_id: this.$groupId
            });
        }
        const params = {
            ...options,
            comment_id: this.id,
            owner_id: this.ownerId
        };
        if (this.isPhotoComment) {
            // @ts-ignore
            return this.vk.api.photos.editComment(params);
        }
        if (this.isVideoComment) {
            // @ts-ignore
            return this.vk.api.video.editComment(params);
        }
        if (this.isWallComment) {
            // @ts-ignore
            return this.vk.api.wall.editComment(params);
        }
        if (this.isMarketComment) {
            // @ts-ignore
            return this.vk.api.market.editComment(params);
        }
        return Promise.reject(new VKError({
            message: 'Unsupported event for editing comment',
            code: 'UNSUPPORTED_EVENT'
        }));
    }
    /**
     * Removes comment
     */
    deleteComment() {
        if (this.isDelete) {
            return Promise.reject(new VKError({
                message: 'Comment is deleted',
                code: 'ALREADY_DELETED'
            }));
        }
        if (this.isBoardComment) {
            // @ts-ignore
            return this.vk.api.board.deleteComment({
                comment_id: this.id,
                topic_id: this.objectId,
                group_id: this.$groupId
            });
        }
        const params = {
            comment_id: this.id,
            owner_id: this.ownerId
        };
        if (this.isPhotoComment) {
            // @ts-ignore
            return this.vk.api.photos.deleteComment(params);
        }
        if (this.isVideoComment) {
            // @ts-ignore
            return this.vk.api.video.deleteComment(params);
        }
        if (this.isWallComment) {
            // @ts-ignore
            return this.vk.api.wall.deleteComment(params);
        }
        if (this.isMarketComment) {
            // @ts-ignore
            return this.vk.api.market.deleteComment(params);
        }
        return Promise.reject(new VKError({
            message: 'Unsupported event for deleting comment',
            code: 'UNSUPPORTED_EVENT'
        }));
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        const properties = [
            'id',
            'replyId',
            'userId',
            'replyUserId',
            'removerUserId',
            'objectId',
            'ownerId',
            'createdAt',
            'text',
            'likes',
            'attachments',
            'isReply'
        ];
        const filtredEmptyProperties = properties.filter(property => (
        // @ts-ignore
        this[property] !== null));
        // @ts-ignore
        return copyParams(this, filtredEmptyProperties);
    }
}
applyMixins(CommentActionContext, [Attachmentable]);

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const subTypes$9 = {
    photo_new: ['new_photo_attachment', PhotoAttachment],
    video_new: ['new_video_attachment', VideoAttachment],
    audio_new: ['new_audio_attachment', AudioAttachment]
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class NewAttachmentsContext extends Context {
    constructor(options) {
        const [subType, PayloadAttachment] = subTypes$9[options.updateType];
        super({
            ...options,
            type: 'new_attachment',
            subTypes: [
                subType
            ]
        });
        this.attachments = [new PayloadAttachment(this.payload, this.vk)];
    }
    /**
     * Checks is attachment photo
     */
    get isPhoto() {
        return this.subTypes.includes('new_photo_attachment');
    }
    /**
     * Checks is attachment video
     */
    get isVideo() {
        return this.subTypes.includes('new_video_attachment');
    }
    /**
     * Checks is attachment audio
     */
    get isAudio() {
        return this.subTypes.includes('new_audio_attachment');
    }
    /**
     * Removes the attachment
     */
    deleteAttachment() {
        if (this.isPhoto) {
            const [photo] = this.getAttachments(AttachmentType.PHOTO);
            return this.vk.api.photos.delete({
                owner_id: photo.ownerId,
                photo_id: photo.id
            });
        }
        if (this.isVideo) {
            const [video] = this.getAttachments(AttachmentType.VIDEO);
            return this.vk.api.video.delete({
                owner_id: video.ownerId,
                video_id: video.id
            });
        }
        if (this.isAudio) {
            const [audio] = this.getAttachments(AttachmentType.AUDIO);
            // @ts-ignore
            return this.vk.api.audio.delete({
                owner_id: audio.ownerId,
                audio_id: audio.id
            });
        }
        return Promise.reject(new VKError({
            message: 'Unsupported event for deleting attachment',
            code: 'UNSUPPORTED_EVENT'
        }));
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'attachments',
            'isPhoto',
            'isVideo',
            'isAudio'
        ]);
    }
}
applyMixins(NewAttachmentsContext, [Attachmentable]);

const subTypes$a = {
    13: 'delete_messages',
    14: 'restore_messages'
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class RemovedMessagesContext extends Context {
    constructor(options) {
        const [eventId, peerId, id] = options.payload;
        super({
            ...options,
            type: 'removed_messages',
            subTypes: [
                subTypes$a[eventId]
            ],
            payload: {
                peer_id: peerId,
                id
            }
        });
    }
    /**
     * Checks that messages have been deleted
     */
    get isRemoved() {
        return this.subTypes.includes('delete_messages');
    }
    /**
     * Checks that messages have been restored
     */
    get isRecovery() {
        return this.subTypes.includes('restore_messages');
    }
    /**
     * Returns the identifier of the message
     */
    get id() {
        return this.payload.id;
    }
    /**
     * Returns the peer ID
     */
    get peerId() {
        return this.payload.peer_id;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'id',
            'peerId',
            'isRemoved',
            'isRecovery'
        ]);
    }
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
class VKPayTransactionContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'vk_pay_transaction',
            subTypes: ['vk_pay_transfer']
        });
    }
    /**
     * Returns the identifier transfer sender
     */
    get fromId() {
        return this.payload.from_id;
    }
    /**
     * Returns the transfer amount in thousandths of a ruble
     */
    get amount() {
        return this.payload.amount;
    }
    /**
     * Returns the description on the translation
     */
    get description() {
        return this.payload.description;
    }
    /**
     * Returns the unixtime transfer time
     */
    get createdAt() {
        return this.payload.date;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'fromId',
            'amount',
            'description',
            'createdAt'
        ]);
    }
}

const { NEED_RESTART, POLLING_REQUEST_FAILED } = UpdatesErrorCode;
const debug$2 = createDebug('vk-io:updates');
/**
 * Version polling
 */
const POLLING_VERSION = 3;
class PollingTransport {
    constructor(vk) {
        this.started = false;
        /**
         * 2 -  Attachments
         * 8 -  Extended events
         * 64 - Online user platform ID
         */
        // eslint-disable-next-line no-bitwise
        this.mode = 2 | 8 | 64;
        this.ts = 0;
        this.pts = 0;
        this.restarted = 0;
        this.vk = vk;
    }
    async start() {
        if (this.started) {
            throw new Error('Polling updates already started');
        }
        if (!this.pollingHandler) {
            throw new Error('You didn\'t subscribe to updates');
        }
        this.started = true;
        try {
            const { pollingGroupId } = this.vk.options;
            const isGroup = pollingGroupId !== null;
            const { server, key, ts } = isGroup
                ? await this.vk.api.groups.getLongPollServer({
                    group_id: pollingGroupId
                })
                : await this.vk.api.messages.getLongPollServer({
                    lp_version: POLLING_VERSION
                });
            if (this.ts === 0) {
                this.ts = ts;
            }
            const pollingURL = isGroup
                ? server
                : `https://${server}`;
            this.url = new URL(pollingURL);
            this.url.search = String(new URLSearchParams({
                key,
                act: 'a_check',
                wait: '25',
                mode: String(this.mode),
                version: String(POLLING_VERSION)
            }));
            this.startFetchLoop();
            debug$2(`${isGroup ? 'Bot' : 'User'} Polling started`);
        }
        catch (error) {
            this.started = false;
            throw error;
        }
    }
    /**
     * Stopping gets updates
     */
    async stop() {
        this.started = false;
        this.restarted = 0;
    }
    /**
     * Starts forever fetch updates  loop
     */
    async startFetchLoop() {
        try {
            while (this.started) {
                await this.fetchUpdates();
            }
        }
        catch (error) {
            debug$2('longpoll error', error);
            const { pollingWait, pollingAttempts } = this.vk.options;
            if (error.code !== NEED_RESTART && this.restarted < pollingAttempts) {
                this.restarted += 1;
                debug$2('longpoll restart request');
                await delay(3e3);
                this.startFetchLoop();
                return;
            }
            while (this.started) {
                try {
                    await this.stop();
                    await this.start();
                    break;
                }
                catch (restartError) {
                    debug$2('longpoll restarted error', restartError);
                    this.started = true;
                    await delay(pollingWait);
                }
            }
        }
    }
    /**
     * Gets updates
     */
    async fetchUpdates() {
        this.url.searchParams.set('ts', String(this.ts));
        debug$2('http -->');
        const response = await fetch(this.url, {
            agent: this.vk.options.agent,
            method: 'GET',
            timeout: 30e3,
            compress: false,
            headers: {
                connection: 'keep-alive'
            }
        });
        debug$2(`http <-- ${response.status}`);
        if (!response.ok) {
            throw new UpdatesError({
                code: POLLING_REQUEST_FAILED,
                message: 'Polling request failed'
            });
        }
        const result = await response.json();
        if (result.failed !== undefined) {
            if (result.failed === 1) {
                this.ts = result.ts;
                return;
            }
            this.ts = 0;
            throw new UpdatesError({
                code: NEED_RESTART,
                message: 'The server has failed'
            });
        }
        this.restarted = 0;
        this.ts = result.ts;
        if (result.pts) {
            this.pts = Number(result.pts);
        }
        /* Async handle updates */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        result.updates.forEach(async (update) => {
            try {
                await this.pollingHandler(update);
            }
            catch (error) {
                // eslint-disable-next-line no-console
                console.error('Handle polling update error:', error);
            }
        });
    }
    subscribe(handler) {
        this.pollingHandler = handler;
    }
}

const splitPath = (path) => (path
    .replace(/\[([^[\]]*)\]/g, '.$1.')
    .split('.')
    .filter(Boolean));
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const getObjectValue = (source, selectors) => {
    let link = source;
    for (const selector of selectors) {
        if (!link[selector]) {
            return undefined;
        }
        link = link[selector];
    }
    return link;
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const unifyCondition = (condition) => {
    if (typeof condition === 'function') {
        return condition;
    }
    if (condition instanceof RegExp) {
        return (text) => (condition.test(text));
    }
    if (Array.isArray(condition)) {
        const arrayConditions = condition.map(unifyCondition);
        return (value) => (Array.isArray(value)
            ? arrayConditions.every((cond) => (value.some((val) => cond(val))))
            : arrayConditions.some((cond) => (cond(value))));
    }
    return (value) => value === condition;
};
const parseRequestJSON = (req, res) => (new Promise((resolve, reject) => {
    let body = '';
    req.on('error', reject);
    req.on('data', (chunk) => {
        if (body.length > 1e6) {
            res.writeHead(413);
            res.end();
            req.connection.destroy();
            reject();
            return;
        }
        body += String(chunk);
    });
    req.on('end', () => {
        try {
            const json = JSON.parse(body);
            resolve(json);
        }
        catch (e) {
            reject(e);
        }
    });
}));

const debug$3 = createDebug('vk-io:updates');
class WebhookTransport {
    constructor(vk) {
        this.started = false;
        this.webhookServer = null;
        this.vk = vk;
    }
    /**
     * Starts the webhook server
     */
    async start({ path = '/', tls, host, port } = {}, next) {
        if (this.started) {
            throw new Error('Webhook updates already started');
        }
        if (!this.webhookHandler) {
            throw new Error('You didn\'t subscribe to updates');
        }
        this.started = true;
        try {
            const webhookCallback = this.getWebhookCallback(path);
            const callback = typeof next === 'function'
                ? (req, res) => (webhookCallback(req, res, () => (next(req, res))))
                : (req, res) => (webhookCallback(req, res, () => {
                    res.writeHead(403);
                    res.end();
                }));
            this.webhookServer = tls
                ? createServer(tls, callback)
                : createServer$1(callback);
            const { webhookServer } = this;
            const listen = promisify(webhookServer.listen).bind(webhookServer);
            const serverPort = port || (tls
                ? 443
                : 80);
            // @ts-ignore
            await listen(serverPort, host);
            debug$3(`Webhook listening on port: ${serverPort}`);
        }
        catch (error) {
            this.started = false;
            throw error;
        }
    }
    /**
     * Stopping gets updates
     */
    async stop() {
        this.started = false;
        if (this.webhookServer !== null) {
            const { webhookServer } = this;
            const close = promisify(webhookServer.close).bind(webhookServer);
            await close();
            this.webhookServer = null;
        }
    }
    /**
     * Returns webhook callback like http[s] or express
     */
    getWebhookCallback(path = null) {
        const headers = {
            connection: 'keep-alive',
            'content-type': 'text/plain'
        };
        const checkIsNotValidPath = path !== null
            ? (requestPath) => requestPath !== path
            : () => false;
        return async (req, res, next) => {
            if (req.method !== 'POST' || checkIsNotValidPath(req.url)) {
                next();
                return;
            }
            let update;
            try {
                // @ts-ignore
                update = typeof req.body !== 'object'
                    ? await parseRequestJSON(req, res)
                    // @ts-ignore
                    : req.body;
            }
            catch (e) {
                debug$3(e);
                return;
            }
            try {
                const { webhookSecret, webhookConfirmation } = this.vk.options;
                if (webhookSecret !== null && update.secret !== webhookSecret) {
                    res.writeHead(403);
                    res.end();
                    return;
                }
                if (update.type === 'confirmation') {
                    if (webhookConfirmation === null) {
                        res.writeHead(500);
                        res.end();
                        return;
                    }
                    res.writeHead(200, headers);
                    res.end(String(webhookConfirmation));
                    return;
                }
                res.writeHead(200, headers);
                res.end('ok');
                this.webhookHandler(update).catch((error) => {
                    // eslint-disable-next-line no-console
                    console.error('Handle webhook update error', error);
                });
            }
            catch (error) {
                debug$3('webhook error', error);
                res.writeHead(415);
                res.end();
            }
        };
    }
    subscribe(handler) {
        this.webhookHandler = handler;
    }
    /**
     * Returns the middleware for the webhook under koa
     */
    getKoaWebhookMiddleware() {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return async (context) => {
            const update = context.request.body;
            const { webhookSecret, webhookConfirmation } = this.vk.options;
            if (webhookSecret !== null && update.secret !== webhookSecret) {
                context.status = 403;
                return;
            }
            if (update.type === 'confirmation') {
                if (webhookConfirmation === null) {
                    context.status = 500;
                    return;
                }
                context.body = webhookConfirmation;
                return;
            }
            context.body = 'ok';
            context.set('connection', 'keep-alive');
            /* Do not delay server response */
            this.webhookHandler(update).catch((error) => {
                // eslint-disable-next-line no-console
                console.error('Handle webhook update error', error);
            });
        };
    }
}

const debug$4 = createDebug('vk-io:updates');
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const webhookContextsEvents = [
    [
        ['message_new', 'message_edit', 'message_reply'],
        MessageContext
    ],
    [
        ['message_allow', 'message_deny'],
        MessageAllowContext
    ],
    [
        ['photo_new', 'audio_new', 'video_new'],
        NewAttachmentsContext
    ],
    [
        ['wall_post_new', 'wall_repost'],
        WallPostContext
    ],
    [
        ['group_join', 'group_leave'],
        GroupMemberContext
    ],
    [
        ['user_block', 'user_unblock'],
        GroupUserContext
    ],
    [
        [
            'photo_comment_new',
            'photo_comment_edit',
            'photo_comment_delete',
            'photo_comment_restore',
            'video_comment_new',
            'video_comment_edit',
            'video_comment_delete',
            'video_comment_restore',
            'wall_reply_new',
            'wall_reply_edit',
            'wall_reply_delete',
            'wall_reply_restore',
            'board_post_new',
            'board_post_edit',
            'board_post_delete',
            'board_post_restore',
            'market_comment_new',
            'market_comment_edit',
            'market_comment_delete',
            'market_comment_restore'
        ],
        CommentActionContext
    ],
    [
        ['poll_vote_new'],
        VoteContext
    ],
    [
        ['group_change_photo', 'group_officers_edit', 'group_change_settings'],
        GroupUpdateContext
    ],
    [
        ['message_typing_state'],
        TypingContext
    ],
    [
        ['app_payload'],
        VKAppPayloadContext
    ],
    [
        ['vkpay_transaction'],
        VKPayTransactionContext
    ]
];
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const pollingContextsEvents = [
    [
        [1, 2, 3],
        MessageFlagsContext
    ],
    [
        [4, 5],
        MessageContext
    ],
    [
        [6, 7],
        ReadMessagesContext
    ],
    [
        [8, 9],
        UserOnlineContext
    ],
    [
        [10, 11, 12],
        DialogFlagsContext
    ],
    [
        [13, 14],
        RemovedMessagesContext
    ],
    [
        [61, 62],
        TypingContext
    ]
];
const makeContexts = (groups) => {
    const contexts = {};
    for (const [events, UpdateContext] of groups) {
        for (const event of events) {
            contexts[event] = UpdateContext;
        }
    }
    return contexts;
};
// @ts-ignore
const webhookContexts = makeContexts(webhookContextsEvents);
// @ts-ignore
const pollingContexts = makeContexts(pollingContextsEvents);
class Updates {
    /**
     * Constructor
     */
    constructor(vk) {
        this.stack = [];
        this.hearStack = [];
        this.hearFallbackHandler = (context, next) => next();
        this.vk = vk;
        this.reloadMiddleware();
        this.pollingTransport = new PollingTransport(vk);
        this.webhookTransport = new WebhookTransport(vk);
        this.webhookTransport.subscribe(this.handleWebhookUpdate.bind(this));
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Checks is started
     */
    get isStarted() {
        return this.pollingTransport.started || this.webhookTransport.started;
    }
    /**
     * Added middleware
     */
    use(middleware) {
        if (typeof middleware !== 'function') {
            throw new TypeError('Middleware must be a function');
        }
        // @ts-ignore
        this.stack.push(middleware);
        this.reloadMiddleware();
        return this;
    }
    on(rawEvents, rawHandlers) {
        const events = !Array.isArray(rawEvents)
            ? [rawEvents]
            : rawEvents;
        const hasEvents = events.every(Boolean);
        if (!hasEvents) {
            throw new Error('Events should be not empty');
        }
        const handler = Array.isArray(rawHandlers)
            ? compose(rawHandlers)
            : rawHandlers;
        if (typeof handler !== 'function') {
            throw new TypeError('Handler must be a function');
        }
        return this.use((context, next) => (context.is(events)
            // @ts-ignore
            ? handler(context, next)
            : next()));
    }
    /**
     * Listen by context condition
     */
    hear(hearConditions, handler) {
        const rawConditions = !Array.isArray(hearConditions)
            ? [hearConditions]
            : hearConditions;
        const hasConditions = rawConditions.every(Boolean);
        if (!hasConditions) {
            throw new Error('Condition should be not empty');
        }
        if (typeof handler !== 'function') {
            throw new TypeError('Handler must be a function');
        }
        let textCondition = false;
        let functionCondtion = false;
        // @ts-ignore
        const conditions = rawConditions.map((condition) => {
            if (typeof condition === 'object' && !(condition instanceof RegExp)) {
                functionCondtion = true;
                const entries = Object.entries(condition).map(([path, value]) => ([splitPath(path), unifyCondition(value)]));
                return (text, context) => (entries.every(([selectors, callback]) => {
                    const value = getObjectValue(context, selectors);
                    return callback(value, context);
                }));
            }
            if (typeof condition === 'function') {
                functionCondtion = true;
                return condition;
            }
            textCondition = true;
            if (condition instanceof RegExp) {
                return (text, context) => {
                    const passed = condition.test(text);
                    if (passed) {
                        context.$match = text.match(condition);
                    }
                    return passed;
                };
            }
            const stringCondition = String(condition);
            return (text) => text === stringCondition;
        });
        const needText = textCondition && functionCondtion === false;
        // @ts-ignore
        this.hearStack.push((context, next) => {
            const { text } = context;
            if (needText && text === null) {
                return next();
            }
            const hasSome = conditions.some((condition) => (condition(text, context)));
            return hasSome
                // @ts-ignore
                ? handler(context, next)
                : next();
        });
        this.reloadMiddleware();
        return this;
    }
    /**
     * A handler that is called when handlers are not found
     */
    setHearFallbackHandler(handler) {
        // @ts-ignore
        this.hearFallbackHandler = handler;
        this.reloadMiddleware();
        return this;
    }
    /**
     * Handles longpoll event
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    handlePollingUpdate(update) {
        debug$4('longpoll update', update);
        const { 0: type } = update;
        const UpdateContext = pollingContexts[type];
        if (!UpdateContext) {
            debug$4(`Unsupported polling context type ${type}`);
            return Promise.resolve();
        }
        // @ts-ignore
        return this.dispatchMiddleware(new UpdateContext({
            vk: this.vk,
            payload: update,
            updateType: type,
            source: UpdateSource.POLLING
        }));
    }
    /**
     * Handles webhook event
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    handleWebhookUpdate(update) {
        debug$4('webhook update', update);
        const { type, object: payload, group_id: groupId } = update;
        const UpdateContext = webhookContexts[type];
        if (!UpdateContext) {
            debug$4(`Unsupported webhook context type ${type}`);
            return Promise.resolve();
        }
        // @ts-ignore
        return this.dispatchMiddleware(new UpdateContext({
            vk: this.vk,
            payload,
            groupId,
            updateType: type,
            source: UpdateSource.WEBHOOK
        }));
    }
    /**
     * Starts to poll server
     */
    startPolling() {
        const { pollingGroupId } = this.vk.options;
        const isGroup = pollingGroupId !== null;
        this.pollingTransport.subscribe(isGroup
            ? this.handleWebhookUpdate.bind(this)
            : this.handlePollingUpdate.bind(this));
        return this.pollingTransport.start();
    }
    /**
     * Starts the webhook server
     */
    async startWebhook(options = {}, next) {
        return this.webhookTransport.start(options, next);
    }
    /**
     * Automatically determines the settings to run
     */
    async start({ webhook } = {}) {
        if (webhook) {
            await this.startWebhook(webhook);
            return;
        }
        if (!this.vk.options.pollingGroupId) {
            try {
                const [group] = await this.vk.api.groups.getById({});
                this.vk.options.pollingGroupId = group.id;
            }
            catch (error) {
                if (error.code !== APIErrorCode.WRONG_PARAMETER) {
                    throw error;
                }
                debug$4('This is not a group.');
            }
        }
        await this.startPolling();
    }
    /**
     * Stopping gets updates
     */
    async stop() {
        await Promise.all([
            this.pollingTransport.stop(),
            this.webhookTransport.stop()
        ]);
    }
    /**
     * Returns webhook callback like http[s] or express
     */
    getWebhookCallback(path = null) {
        return this.webhookTransport.getWebhookCallback(path);
    }
    /**
     * Returns the middleware for the webhook under koa
     */
    getKoaWebhookMiddleware() {
        return this.webhookTransport.getKoaWebhookMiddleware();
    }
    /**
     * Calls up the middleware chain
     */
    dispatchMiddleware(context) {
        return this.stackMiddleware(context, noopNext);
    }
    /**
     * Reloads middleware
     */
    reloadMiddleware() {
        const stack = [...this.stack];
        if (this.hearStack.length !== 0) {
            stack.push(
            // @ts-ignore
            getOptionalMiddleware((context) => context.is('new_message') && !context.isEvent, compose([
                ...this.hearStack,
                this.hearFallbackHandler
            ])));
        }
        this.stackMiddleware = compose(stack);
    }
    /**
     * Custom inspect object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [inspect.custom](depth, options) {
        const { isStarted, stack } = this;
        const payload = { isStarted, stack };
        return `${options.stylize(this.constructor.name, 'special')} ${inspect(payload, options)}`;
    }
}

const { INVALID_URL, INVALID_RESOURCE, RESOURCE_NOT_FOUND } = SnippetErrorCode;
const numberRe = /^-?\d+$/;
const hasProtocolRe = /https?:\/\//i;
const isVKUrl = /^(?:https?:\/\/)?(?:m\.)?vk\.com/i;
const isUserMentionRe = /\*|@/;
const systemMentionRe = /\[([^|]+)|([^|\]]+)\]/;
/**
 * Switch resource types
 */
const enumResourceTypes = {
    id: ResourceType.USER,
    club: ResourceType.GROUP,
    public: ResourceType.GROUP,
    app: ResourceType.APPLICATION
};
/**
 * Remove search param
 */
const removeSearchParam = /(\?|&)[^=]+=/;
/**
 * Resolve the attachment resource
 */
const resolveOwnerResource = (resource, pattern) => {
    const { 1: type, 2: owner, 3: id } = resource.match(pattern);
    return {
        id: Number(id),
        owner: Number(owner),
        type: type.toLowerCase().replace(removeSearchParam, '')
    };
};
class ResourceResolver {
    /**
     * Constructor
     */
    constructor(vk) {
        this.vk = vk;
    }
    /**
     * Resolve resource
     */
    async resolve(rawResource) {
        if (!rawResource) {
            throw new SnippetsError({
                code: INVALID_RESOURCE,
                message: 'Resource is required'
            });
        }
        const resource = String(rawResource).trim();
        if (numberRe.test(resource)) {
            return this.resolveNumber(Number(resource));
        }
        const isMention = (isUserMentionRe.test(resource) || systemMentionRe.test(resource));
        if (isMention) {
            return this.resolveMention(resource);
        }
        if (isVKUrl.test(resource)) {
            return this.resolveUrl(resource);
        }
        return this.resolveScreenName(resource);
    }
    /**
     * Resolve number
     */
    resolveNumber(resource) {
        const isGroup = resource < 0;
        const type = isGroup
            ? 'club'
            : 'id';
        return this.resolveScreenName(type + (isGroup
            ? -resource
            : resource));
    }
    /**
     * Resolve resource mention
     */
    resolveMention(resource) {
        if (isUserMentionRe.test(resource)) {
            return this.resolveScreenName(resource.substring(1));
        }
        const { 1: mentionResource } = resource.match(systemMentionRe);
        return this.resolveScreenName(mentionResource);
    }
    /**
     * Resolve resource url
     */
    async resolveUrl(rawResourceUrl) {
        const resourceUrl = !hasProtocolRe.test(rawResourceUrl)
            ? `https://${rawResourceUrl}`
            : rawResourceUrl;
        const { pathname, search } = new URL(resourceUrl);
        if (pathname === '/') {
            throw new SnippetsError({
                code: INVALID_URL,
                message: 'URL should contain path'
            });
        }
        if (parseAttachment.test(search)) {
            return resolveOwnerResource(search, parseAttachment);
        }
        if (parseOwnerResource.test(search)) {
            return resolveOwnerResource(search, parseOwnerResource);
        }
        return this.resolveScreenName(pathname.substring(1));
    }
    /**
     * Resolve screen name
     */
    async resolveScreenName(resource) {
        if (parseAttachment.test(resource)) {
            return resolveOwnerResource(resource, parseAttachment);
        }
        if (parseOwnerResource.test(resource)) {
            return resolveOwnerResource(resource, parseOwnerResource);
        }
        if (parseResource.test(resource)) {
            const { 1: typeResource, 2: id } = resource.match(parseResource);
            let type = typeResource.toLowerCase();
            if (type in enumResourceTypes) {
                type = enumResourceTypes[type];
            }
            return {
                id: Number(id),
                type
            };
        }
        // @ts-ignore
        const response = await this.vk.api.utils.resolveScreenName({
            screen_name: resource
        });
        if (Array.isArray(response)) {
            throw new SnippetsError({
                message: 'Resource not found',
                code: RESOURCE_NOT_FOUND
            });
        }
        // @ts-ignore
        const { type, object_id: id } = response;
        if (type === 'page') {
            return {
                id,
                type: ResourceType.GROUP
            };
        }
        return { id, type };
    }
}

class Snippets {
    /**
     * Constructor
     */
    constructor(vk) {
        this.vk = vk;
        this.resourceResolver = new ResourceResolver(this.vk);
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Defines the type of object (user, community, application, attachment)
     */
    resolveResource(resource) {
        return this.resourceResolver.resolve(resource);
    }
}

const { MISSING_CAPTCHA_HANDLER, MISSING_TWO_FACTOR_HANDLER } = SharedErrorCode;
class CallbackService {
    /**
     * Constructor
     */
    constructor(vk) {
        this.captchaHandler = null;
        this.twoFactorHandler = null;
        this.vk = vk;
    }
    /**
     * Checks if there is a captcha handler
     */
    get hasCaptchaHandler() {
        return this.captchaHandler !== null;
    }
    /**
     * Checks if there is a two-factor handler
     */
    get hasTwoFactorHandler() {
        return this.twoFactorHandler !== null;
    }
    /**
     * Processing captcha
     */
    processingCaptcha(payload) {
        return new Promise((resolveProcessing, rejectProcessing) => {
            if (!this.hasCaptchaHandler) {
                rejectProcessing(new VKError({
                    message: 'Missing captcha handler',
                    code: MISSING_CAPTCHA_HANDLER
                }));
                return;
            }
            // @ts-ignore
            this.captchaHandler(payload, (key) => (new Promise((resolve, reject) => {
                if (key instanceof Error) {
                    reject(key);
                    rejectProcessing(key);
                    return;
                }
                // @ts-ignore
                resolveProcessing({
                    key,
                    validate: {
                        resolve,
                        reject
                    }
                });
            })));
        });
    }
    /**
     * Processing two-factor
     */
    processingTwoFactor(payload) {
        return new Promise((resolveProcessing, rejectProcessing) => {
            if (!this.hasTwoFactorHandler) {
                rejectProcessing(new VKError({
                    message: 'Missing two-factor handler',
                    code: MISSING_TWO_FACTOR_HANDLER
                }));
                return;
            }
            // @ts-ignore
            this.twoFactorHandler(payload, (code) => (new Promise((resolve, reject) => {
                if (code instanceof Error) {
                    reject(code);
                    rejectProcessing(code);
                    return;
                }
                // @ts-ignore
                resolveProcessing({
                    code,
                    validate: {
                        resolve,
                        reject
                    }
                });
            })));
        });
    }
}

const kAuth = Symbol('auth');
const kStreaming = Symbol('streaming');
/**
 * Main class
 */
class VK {
    /**
     * Constructor
     */
    constructor(options = {}) {
        this.options = {
            ...defaultOptions,
            agent: new Agent({
                keepAlive: true,
                keepAliveMsecs: 10000
            })
        };
        this.api = new API(this);
        this.upload = new Upload(this);
        this.collect = new Collect(this);
        this.updates = new Updates(this);
        this.snippets = new Snippets(this);
        this.callbackService = new CallbackService(this);
        this.setOptions(options);
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    get auth() {
        if (!this[kAuth]) {
            showDeprecatedMessage('vk.auth deprecated, use @vk-io/authorization instead');
            // eslint-disable-next-line
            this[kAuth] = new (require('@vk-io/authorization').Authorization)(this);
        }
        return this[kAuth];
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    get streaming() {
        if (!this[kStreaming]) {
            showDeprecatedMessage('vk.streaming deprecated, use @vk-io/streaming instead');
            // eslint-disable-next-line
            this[kStreaming] = new (require('@vk-io/streaming').StreamingAPI)(this);
        }
        return this[kStreaming];
    }
    /**
     * Sets options
     */
    setOptions(options) {
        Object.assign(this.options, options);
        return this;
    }
    /**
     * Sets token
     */
    set token(token) {
        this.options.token = token;
    }
    /**
     * Returns token
     */
    get token() {
        return this.options.token;
    }
    /**
     * Sets captcha handler
     *
     * ```ts
     * vk.captchaHandler = (payload, retry) => {...};
     * ```
     */
    set captchaHandler(handler) {
        this.callbackService.captchaHandler = handler;
    }
    /**
     * Sets two-factor handler
     *
     * ```ts
     * vk.twoFactorHandler = (payload, retry) => {...};
     * ```
     */
    set twoFactorHandler(handler) {
        this.callbackService.twoFactorHandler = handler;
    }
    /**
     * Custom inspect object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [inspect.custom](depth, options) {
        const { api, updates } = this;
        const { appId, token, login, phone } = this.options;
        const payload = {
            options: {
                appId,
                login,
                phone,
                token
            },
            api,
            updates
        };
        return `${options.stylize(this.constructor.name, 'special')} ${inspect(payload, options)}`;
    }
}

/**
 * Primary colors used in the text button
 */
// eslint-disable-next-line import/prefer-default-export
var ButtonColor;
(function (ButtonColor) {
    /**
     * The white button, indicates secondary action
     *
     * Hex color #FFFFFF
     */
    ButtonColor["SECONDARY"] = "secondary";
    /**
     * The blue button, indicates the main action
     *
     * Hex color #5181B8
     */
    ButtonColor["PRIMARY"] = "primary";
    /**
     * The red button, indicates a dangerous or a negative action (reject, delete, etc...)
     *
     * Hex color #E64646
     */
    ButtonColor["NEGATIVE"] = "negative";
    /**
     * The green button, indicates a agree, confirm, ...etc
     *
     * Hex color #4BB34B
     */
    ButtonColor["POSITIVE"] = "positive";
})(ButtonColor || (ButtonColor = {}));

class KeyboardBuilder {
    constructor() {
        /**
         * Does the keyboard close after pressing the button
         */
        this.isOneTime = false;
        /**
         * The keyboard must be attached to the message
         */
        this.isInline = false;
        /**
         * Rows with all buttons
         */
        this.rows = [];
        /**
         * Current row of buttons
         */
        this.currentRow = [];
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Text button, can be colored
     *
     * ```ts
     * builder.textButton({
     *  label: 'Buy a coffee',
     *  payload: {
     *   command: 'buy',
     *   item: 'coffee'
     *  },
     *  color: Keyboard.POSITIVE_COLOR
     * });
     * ```
     */
    textButton({ label, payload: rawPayload = {}, color = ButtonColor.SECONDARY }) {
        if (label.length > 40) {
            throw new RangeError('Maximum length of label 40 characters');
        }
        const payload = JSON.stringify(rawPayload);
        if (payload.length > 255) {
            throw new RangeError('Maximum length of payload 255 characters');
        }
        return this.addButton({
            color,
            action: {
                label,
                payload,
                type: 'text'
            }
        });
    }
    /**
     * URL button
     *
     * ```ts
     * builder.urlButton({
     *  label: 'Buy a coffee',
     *  url: 'https://coffee.mania/buy
     * });
     * ```
     */
    urlButton({ label, url, payload: rawPayload = {} }) {
        if (label.length > 40) {
            throw new RangeError('Maximum length of label 40 characters');
        }
        const payload = JSON.stringify(rawPayload);
        if (payload.length > 255) {
            throw new RangeError('Maximum length of payload 255 characters');
        }
        return this.addWideButton({
            action: {
                label,
                payload,
                link: url,
                type: 'open_link'
            }
        });
    }
    /**
     * User location request button, occupies the entire keyboard width
     *
     * ```ts
     * builder.locationRequestButton({
     *  payload: {
     *   command: 'order_delivery'
     *  }
     * })
     * ```
     */
    locationRequestButton({ payload: rawPayload = {} }) {
        const payload = JSON.stringify(rawPayload);
        if (payload.length > 255) {
            throw new RangeError('Maximum length of payload 255 characters');
        }
        return this.addWideButton({
            action: {
                payload,
                type: 'location'
            }
        });
    }
    /**
     * VK Pay button, occupies the entire keyboard width
     *
     * ```ts
     * builder.payButton({
     *  hash: {
     *   action: 'transfer-to-group',
     *   group_id: 1,
     *   aid: 10
     *  }
     * })
     * ```
     */
    payButton({ hash: rawHash }) {
        const hash = typeof rawHash === 'object'
            ? String(new URLSearchParams(Object.entries(rawHash)))
            : rawHash;
        return this.addWideButton({
            action: {
                hash,
                type: 'vkpay'
            }
        });
    }
    /**
     * VK Apps button, occupies the entire keyboard width
     *
     * ```ts
     * builder.applicationButton({
     *  label: 'LiveWidget',
     *  appId: 6232540,
     *  ownerId: -157525928
     * })
     * ```
     */
    applicationButton({ label, appId, ownerId, hash }) {
        if (label.length > 40) {
            throw new RangeError('Maximum length of label 40 characters');
        }
        return this.addWideButton({
            action: {
                label,
                hash,
                app_id: appId,
                owner_id: ownerId,
                type: 'open_app'
            }
        });
    }
    /**
     * Saves the current row of buttons in the general rows
     */
    row() {
        if (this.currentRow.length === 0) {
            return this;
        }
        if (this.currentRow.length > 5) {
            throw new RangeError('Max count of buttons at columns 5');
        }
        this.rows.push(this.currentRow);
        this.currentRow = [];
        return this;
    }
    /**
     * Sets the keyboard to close after pressing
     *
     * ```ts
     *  builder.oneTime();
     *
     *  builder.oneTime(false);
     * ```
     */
    oneTime(enabled = true) {
        this.isOneTime = enabled;
        return this;
    }
    /**
     * Sets the keyboard inline
     *
     * ```ts
     *  builder.inline();
     *
     *  builder.inline(false);
     * ```
     */
    inline(enabled = true) {
        this.isInline = enabled;
        return this;
    }
    /**
     * Clones the builder with all the settings
     */
    clone() {
        const builder = new KeyboardBuilder();
        builder.oneTime(this.isOneTime);
        builder.inline(this.isInline);
        builder.rows = [...this.rows];
        builder.currentRow = [...this.currentRow];
        return builder;
    }
    /**
     * Returns a string to keyboard a VK
     */
    toString() {
        const maxRowsLength = this.isInline
            ? 6
            : 10;
        if (this.rows.length > maxRowsLength) {
            throw new RangeError(`Max count of keyboard rows ${maxRowsLength}`);
        }
        const buttons = this.currentRow.length !== 0
            ? [...this.rows, this.currentRow]
            : this.rows;
        return JSON.stringify(this.isInline
            ? {
                buttons,
                inline: true
            }
            : {
                buttons,
                one_time: this.isOneTime
            });
    }
    /**
     * Adds a button to the current row
     */
    addButton(button) {
        this.currentRow.push(button);
        return this;
    }
    /**
     * Adds a wide button to the new row
     */
    addWideButton(button) {
        if (this.currentRow.length >= 2) {
            this.row();
        }
        this.addButton(button);
        if (this.currentRow.length === 2) {
            this.row();
        }
        return this;
    }
}

class Keyboard {
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * @deprecated Use Keyboard.SECONDARY_COLOR instead
     */
    // eslint-disable-next-line class-methods-use-this
    static get DEFAULT_COLOR() {
        // eslint-disable-next-line no-console
        showDeprecatedMessage('Keyboard.DEFAULT_COLOR deprecated, use Keyboard.SECONDARY_COLOR instead');
        return ButtonColor.SECONDARY;
    }
    /**
     * The white button, indicates secondary action
     *
     * Hex color #FFFFFF
     */
    // eslint-disable-next-line class-methods-use-this
    static get SECONDARY_COLOR() {
        return ButtonColor.SECONDARY;
    }
    /**
     * The blue button, indicates the main action
     *
     * Hex color #5181B8
     */
    // eslint-disable-next-line class-methods-use-this
    static get PRIMARY_COLOR() {
        return ButtonColor.PRIMARY;
    }
    /**
     * The red button, indicates a dangerous or a negative action (reject, delete, etc...)
     *
     * Hex color #E64646
     */
    // eslint-disable-next-line class-methods-use-this
    static get NEGATIVE_COLOR() {
        return ButtonColor.NEGATIVE;
    }
    /**
     * The green button, indicates a agree, confirm, ...etc
     *
     * Hex color #4BB34B
     */
    // eslint-disable-next-line class-methods-use-this
    static get POSITIVE_COLOR() {
        return ButtonColor.POSITIVE;
    }
    /**
     * Returns keyboard builder
     */
    static builder() {
        return new KeyboardBuilder();
    }
    /**
     * Assembles a builder of buttons
     */
    static keyboard(rows) {
        const builder = new KeyboardBuilder();
        for (const row of rows) {
            const buttons = Array.isArray(row)
                ? row
                : [row];
            for (const { kind, options } of buttons) {
                if (kind === 'text') {
                    builder.textButton(options);
                    continue;
                }
                if (kind === 'url') {
                    builder.urlButton(options);
                    continue;
                }
                if (kind === 'location_request') {
                    builder.locationRequestButton(options);
                    continue;
                }
                if (kind === 'vk_pay') {
                    builder.payButton(options);
                    continue;
                }
                if (kind === 'vk_application') {
                    builder.applicationButton(options);
                    continue;
                }
                throw new TypeError('Unsupported type button');
            }
            builder.row();
        }
        return builder;
    }
    /**
     * Text button, can be colored
     */
    static textButton(options) {
        return { options, kind: 'text' };
    }
    /**
     * URL button
     */
    static urlButton(options) {
        return { options, kind: 'url' };
    }
    /**
     * User location request button, occupies the entire keyboard width
     */
    static locationRequestButton(options) {
        return { options, kind: 'location_request' };
    }
    /**
     * VK Pay button, occupies the entire keyboard width
     */
    static payButton(options) {
        return { options, kind: 'vk_pay' };
    }
    /**
     * VK Apps button, occupies the entire keyboard width
     */
    static applicationButton(options) {
        return { options, kind: 'vk_application' };
    }
}

class Composer extends Composer$1 {
    /**
     * Create new `Composer` instance
     */
    static builder() {
        return new Composer();
    }
}

export default VK;
export { APIError, APIErrorCode, APIRequest, Attachment, AttachmentType, AudioAttachment, AudioMessageAttachment, ButtonColor, CaptchaType, CollectError, CollectErrorCode, CommentActionContext, Composer, Context, DialogFlagsContext, DocumentAttachment, ExecuteError, ExternalAttachment, GiftAttachment, GraffitiAttachment, GroupMemberContext, GroupUpdateContext, GroupUserContext, Keyboard, KeyboardBuilder, LinkAttachment, MarketAlbumAttachment, MarketAttachment, MessageAllowContext, MessageContext, MessageFlagsContext, MessageSource, NewAttachmentsContext, PhotoAttachment, PollAttachment, ReadMessagesContext, RemovedMessagesContext, APIRequest as Request, ResourceType, SharedErrorCode, SnippetErrorCode, SnippetsError, StickerAttachment, StoryAttachment, TypingContext, UpdateSource, UpdatesError, UpdatesErrorCode, UploadError, UploadErrorCode, UserOnlineContext, VK, VKAppPayloadContext, VKError, VKPayTransactionContext, VideoAttachment, VoteContext, WallAttachment, WallPostContext, WallReplyAttachment, apiErrors, attachmentTypes, captchaTypes, collectErrors, inspectCustomData, messageSources, platforms, resourceTypes, sharedErrors, snippetsErrors, transformAttachments, updatesErrors, uploadErrors };
