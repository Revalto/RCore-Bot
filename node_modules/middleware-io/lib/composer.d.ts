import { Middleware, LazyMiddlewareFactory, BranchMiddlewareCondition, CaughtMiddlewareHandler } from './types';
/**
 * A simple middleware compose builder
 */
export declare class Composer<T extends object, R = T> {
    protected middlewares: Middleware<R>[];
    /**
     * Invokes a new instance of the Composer class
     */
    static builder<Context extends object>(): Composer<Context>;
    /**
     * The number of middleware installed in Composer
     */
    get length(): number;
    /**
     * Clones a composer object
     */
    clone(): Composer<T, R>;
    /**
     * Adds middleware to the chain
     */
    use<V = {}>(middleware: Middleware<T & V>): Composer<T & V, R>;
    /**
     * Lazily asynchronously gets middleware
     */
    lazy<V = {}>(factory: LazyMiddlewareFactory<T & V>): Composer<T & V, R>;
    /**
     * Runs the middleware and force call `next()`
     */
    tap<V = {}>(middleware: Middleware<T & V>): Composer<T & V, R>;
    /**
     * Runs the middleware at the next event loop and force call `next()`
     */
    fork<V = {}>(middleware: Middleware<T & V>): Composer<T & V, R>;
    /**
     * By condition splits the middleware
     */
    branch<V = {}>(condition: BranchMiddlewareCondition<T & V>, trueMiddleware: Middleware<T & V>, falseMiddleware: Middleware<T & V>): Composer<T & V, R>;
    /**
     * Conditionally runs optional middleware or skips middleware
     */
    optional<V = {}>(condition: BranchMiddlewareCondition<T & V>, optionalMiddleware: Middleware<T & V>): Composer<T & V, R>;
    /**
     * Conditionally runs middleware or stops the chain
     */
    filter<V = {}>(condition: BranchMiddlewareCondition<T & V>, filterMiddleware: Middleware<T & V>): Composer<T & V, R>;
    /**
     * Runs the second middleware before the main
     */
    before<V = {}>(beforeMiddleware: Middleware<T & V>, middleware: Middleware<T & V>): Composer<T & V, R>;
    /**
     * Runs the second middleware after the main
     */
    after<V = {}>(middleware: Middleware<T & V>, afterMiddleware: Middleware<T & V>): Composer<T & V, R>;
    /**
     * Runs middleware before and after the main
     */
    enforce<V = {}>(beforeMiddleware: Middleware<T & V>, middleware: Middleware<T & V>, afterMiddleware: Middleware<T & V>): Composer<T & V, R>;
    /**
     * Catches errors in the middleware chain
     */
    caught<V = {}>(errorHandler: CaughtMiddlewareHandler<T & V>): Composer<T & V, R>;
    /**
     * Concurrently launches middleware,
     * the chain will continue if `next()` is called in all middlewares
     */
    concurrency<V = {}>(middlewares: Middleware<T & V>[]): Composer<T & V, R>;
    /**
     * Compose middleware handlers into a single handler
     */
    compose(): Middleware<R>;
}
